---
title: "Random Forest Modelling of the Lake Erie microbial community"
output:
  html_document:
    theme: united
    toc: yes
  pdf_document:
    toc: yes
---
Author: Michelle Berry

Date: 2/24/15

------------

This is some sample code of how to run both regression and classification random forest models with microbial community composition datasets. 

In this example, we are working with illumina 16s data that has already been processed into an otu and taxonomy table. The samples were collected  from Western Lake Erie between May and November 2014 at three different locations. Bacterial DNA was extracted from three types of samples:

1. Full community samples: whole lake water was syringe-filtered onto a .22um PES filter to represent the "full" bacterial community (yes i know there are picoplankton that are smaller than .22um).

2. Algal/particle: This fraction targets cyanobacterial colonies and attached bacteria. Whole lake water was passed through a 100um mesh and the retentate was then filtered onto a glass fiber filter. 

3. Free-living bacteria: This fraction targets just the free-living bacteria, which we defined as anything between 3um and .22um. Lake water was prefiltered through a 53um mesh and then passed through 3um and .22 um filters. 

## Data Import
```{r, message=FALSE,warning=FALSE}
# Load libraries
library(phyloseq)
packageVersion("phyloseq")
library(ggplot2)
library(reshape2)
library(plyr)
library(scales)
library(knitr)
library(randomForest)

# Set working directory
setwd("~/habs/genomics/data/")

# mothur file import
sharedfile = "mothur/furthestneighbor.shared"
taxfile = "mothur/furthestneighbor.taxonomy"
mothurdata = import_mothur(mothur_shared_file = sharedfile ,
                           mothur_constaxonomy_file = taxfile )
mothurdata

# Taxonomy names are listed as Rank1, Rank2 . . . 
colnames(tax_table(mothurdata))

# Change to Kingdom, Phylum . . .
colnames(tax_table(mothurdata)) <- c("Kingdom","Phylum","Class","Order","Family","Genus")

# Import metadata and merge with other object
metadata = "other/metadata_bloom.txt"
map = import_qiime_sample_data(metadata)
map1 <-map[-1,]
colnames(otu_table(mothurdata))<-map1$SampleID
moth_merge = merge_phyloseq(mothurdata,map)

# What variables are in our metadata?
sample_variables(moth_merge)
```


```{r}
# lets filter out samples such as blanks, mock communities and samples that didnt amplify 
moth_good <- subset_samples(moth_merge,Type=="sample" & Intensive=="n")
moth_good <- subset_taxa(moth_good, 
                         Kingdom == "Bacteria" & 
                         Class != "Chloroplast" &
                        Family!="mitochondria"
                          )
moth_good <- prune_taxa(taxa_sums(moth_good)>0,moth_good)
moth_good

```

```{r,echo=FALSE}
scale_reads <- function(physeq,n){
  physeq.scale <- transform_sample_counts(physeq, function(x) {(n*x/sum(x))})
  otu_table(physeq.scale) = floor(otu_table(physeq.scale))
  physeq.scale = prune_taxa(taxa_sums(physeq.scale)>0,physeq.scale)
  return(physeq.scale)
}

order_dates <- function(df){
  df$Date <- factor(df$Date, levels = c("5/27/14","6/10/14","6/16/14","6/30/14","7/8/14","7/14/14","7/21/14","7/29/14","8/4/14","8/11/14","8/18/14","8/25/14","9/2/14","9/8/14","9/15/14","9/23/14","9/29/14","10/6/14","10/15/14","10/20/14","10/27/14","11/3/14"))
  return(df)
}

# This function takes a phyloseq object, agglomerates OTU's to the desired taxonomic rank, prunes out OTUs below a certain relative proportion in a sample (ie 1% ) and melts the phyloseq object into long format.
transform_and_melt<-function(physeq,taxrank,prune){
  
  # Agglomerate all otu's by phylum level
  physeq_phylum<-tax_glom(physeq,taxrank = "Phylum")

  # Create a new phyloseq object which removes taxa from each sample below the prune parameter 
  physeq_phylum.prune = transform_sample_counts(physeq_phylum, 
                                              function(x){x/sum(x)})
  otu_table(physeq_phylum.prune)[otu_table(physeq_phylum.prune)<prune] <- 0 
  physeq_phylum.prune  = prune_taxa(taxa_sums(physeq_phylum.prune)>0,
                                 physeq_phylum.prune)

  # Melt into long format and sort by samplenum and phylum
  physeq_phylum.long<-psmelt(physeq_phylum.prune)
  physeq_phylum.long<-arrange(physeq_phylum.long,Samplenum,Phylum)


  # Reorder factor levels for dates 
  physeq_phylum.long<-order_dates(physeq_phylum.long)
  
  # Reorder factor levers for stations
  physeq_phylum.long$Station <-factor(physeq_phylum.long$Station,
                                      levels=c("WE2","WE12","WE4"))
  return(physeq_phylum.long)
}


# This function takes  a data frame in long format (such as the output from transform_and_melt) and produces a stacked barplot of community composition.   

make_tax_barplot<-function(df,x,tax,title,colors,xlab,ylab){
  ggplot(df,aes_string(x=x,y="Abundance",fill=tax)) +
        facet_grid(Station~.,scales="free")+
        geom_bar(stat="identity")+
        geom_bar(stat="identity",position="fill",colour="black",show_guide=FALSE)+ 
   scale_y_continuous(labels = percent_format())+ 
  scale_fill_manual(values = colors) + 
    theme(axis.title.x = element_text(size=16,face="bold"),
          axis.text.x = element_text(angle=50, colour = "black", vjust=1, hjust = 1, size=9),
          axis.text.y = element_text(colour = "black", size=9),
          axis.title.y = element_text(face="bold", size=16),
          plot.title = element_text(size = 18),
          legend.title = element_text(size=14),
          legend.text = element_text(size = 13),
          legend.position="right",
          strip.text.x = element_text(size=12, face="bold"),
          strip.text.y = element_text(size=12, face="bold"),
          strip.background = element_rect(colour="black"))+
    guides(fill = guide_legend(reverse= TRUE,keywidth=1,keyheight=1))+
    xlab(xlab)+
    ylab(ylab)+
    ggtitle(title)
        
}
```

## Classification rf: modelling algal-associated vs free-living

For this random forest we want to build a model which will classify samples as either "free-living" or "algal/particle". In doing this, we will also pull out which OTUs seem to be associated with the free-living lifestyle, vs attachment to colonial algae

First, we need to do a few things to filter our data and put it in the right format
```{r}
# Select only samples of type 100L (Algal/particle) or 22NA (free-living)
moth_subset<-subset_samples(moth_good,Fraction=="100L"|Fraction=="22NA")

# Normalize read counts by scaling to smallest library size
moth_scaled<-scale_reads(moth_subset,min(sample_sums(moth_subset)))

```

Lets make some barplots to get a sense of what these communities look like. Here is a barplot of phylum composition from all three locations (WE2, WE12, WE4)

```{r,fig.height=8,fig.width=12,message=FALSE,error=FALSE}


# Plot phylum level composition of Particle/algal fraction
F100L <- subset_samples(moth_scaled,Fraction=="100L")

# Set Colors (RColorBrewer)
phy <- c(Acidobacteria="#4D4D4D",Actinobacteria="#ff7f00",Armatimonadetes="#ffff99", 
         Bacteroidetes="#6a3d9a",Candidate_division_SR1 ="#b15928" ,
         Chlorobi="#cab2d6", Chloroflexi="#B2DF8A",
         Chloroplast="darkgreen",Cyanobacteria="#33A02C",
         Gemmatimonadetes="#fdbf6f",Planctomycetes="#A6CEE3",
         Proteobacteria="#1F78B4", unclassified="#fb9a99", 
         Verrucomicrobia ="#e31a1c") 

F100L.long<-transform_and_melt(physeq = F100L,taxrank = "Phylum",prune = .02)

make_tax_barplot(df = F100L.long,x = "Date",tax = "Phylum",
                 title = "Phylum composition of particle/algal-associated bacteria
across three Lake Erie stations\n",
                 colors=phy,
                 xlab="",
                 ylab="Relative Abundance (taxa>2%)")

```

```{r,fig.height=8,fig.width=12,message=FALSE,error=FALSE}

# Plot phylum level composition of Free-living fraction
F22NA <- subset_samples(moth_scaled,Fraction=="22NA")

F22NA.long<-transform_and_melt(physeq = F22NA,taxrank = "Phylum",prune = .02)

make_tax_barplot(df = F22NA.long,x = "Date",tax = "Phylum",
                 title = "Phylum composition of free-living bacteria 
across three Lake Erie stations\n",
                 colors=phy,
                 xlab="",
                 ylab="Relative Abundance (taxa>2%)")
```



Here is an NMDS of the samples colored by free-living or particle/algal. We can already see vsee that these communities are very well segregated, so our random forest model will probably work very well. 

```{r}

# Make an NMDS colored by sample type
# Plot NMDS
theme_set(theme_bw())
bray.nmds = ordinate(moth_scaled,method="NMDS","bray")
plot_ordination(moth_scaled,bray.nmds,color = "Fraction") + 
  geom_point(size=3) + 
  ggtitle("Free-living and Particle/Algal bacterial communities")

````



```{r}
# Make a dataframe of training data with OTUs as column and samples as rows
t_otu <- t(otu_table(moth_scaled))
dim(t_otu)
```
We have 115 samples and 788 OTUs
```{r}
# Make one column for our predictor variable "Fraction"
Fraction <- as.factor(sample_data(moth_scaled)$Fraction)

# Combine them into 1 data frame
rf_data<-data.frame(Fraction,t_otu)

```


Now we will use the randomForest package to train and test our random forest model using the "out of bag" error to estimate our model error. OOB is a nice feature of random forest models whereby since the training data is bootstrapped, you only use approximately 2/3 of the data at each iteration. The remaining 1/3 or "out of bag" data can be used to validate your model. This removes the need to use another form of cross-validation such as using a separate validation set or k-folds.  

### Results
```{r}
# It is important to set a seed for reproducability
# By default, randomForest uses p/3 variables when building 
# a random forest of regression trees and root(p) 
# variables when building a random forest of classification trees. 
# In this case, root(p) = 28
set.seed(1)
rf.erie <- randomForest(Fraction~.,data=rf_data,ntree=100)
print(rf.erie)
```
Our out of bag error is 1.74%

```{r}
# What variables are stored in the output?
names(rf.erie)

```
This model worked really well! We can very accurately classify our bacterial communities into free-living or particle/algal-associated


### plots 
Lets make some plots of the most important variables in our model
```{r}
# Select the importance vactor for the predictors. 
# For a regression tree this is measured by mean decrease in MSE 
# due to that variable
imp <- importance(rf.erie)
imp <- data.frame(predictors=rownames(imp),imp)

# Order the predictor levels by importance
imp.sort <- arrange(imp,desc(MeanDecreaseGini))
imp.sort$predictors <- factor(imp.sort$predictors,levels=imp.sort$predictors)

# Select the top 10 predictors
imp.10<- imp.sort[1:10,]


# ggplot
ggplot(imp.10,aes(x=predictors,y=MeanDecreaseGini))+
  geom_bar(stat="identity",fill="indianred") +
  coord_flip()+
  ggtitle("Most important OTUs for classifying Erie samples \n into free-living or algal-associated")

# What are those OTUs?
otunames<- imp.10$predictors
r <- rownames(tax_table(moth_scaled)) %in% otunames
kable(tax_table(moth_scaled)[r,])
```

## Regression rf: modelling microcystin levels of the whole bacterial community

In this random forest we will attempt to predict the microcystin toxin levels of a bacterial community based on its OTU composition. This is essentially a regression problem using OTU relative abundances as predictors and toxin levels as our outcome. Because there is a time component to these samples we will also include time as a variable. 


```{r}

# Subset the data to select just full community samples
FCNA <- subset_samples(moth_good,Fraction=="CNA")
FCNA.scaled<-scale_reads(FCNA, min(sample_sums(FCNA)))

FCNA.scaled
```

This is a large number of OTUs, so to speed up the model a bit we will remove all rare OTUs that are probably not very biologically relevant

```{r}
# Transform to proportions
FCNA.proportions = transform_sample_counts(FCNA.scaled,function(x){x/sum(x)})

# Remove OTUs below .001 within a sample 
otu_table(FCNA.proportions)[otu_table(FCNA.proportions)<.001] <- 0 
FCNA.pruned = prune_taxa(taxa_sums(FCNA.proportions)>0, FCNA.proportions)
FCNA.pruned                               

```
Now we only have 488 OTUs to put into our model 

```{r}
# Make a dataframe with OTUs as columns, samples as rows, 
# and one column for our predictor variable "Microcystin"
t_otu <- t(otu_table(FCNA.pruned))
dim(t_otu)
# We have 59 samples and 488 OTUs

# Assign particulate Microcystin to a variable
ParMC <- as.vector(sample_data(FCNA.scaled)$ParMC)
# Log transform ParMC because it is highly skewed
ParMC <- log2(ParMC)


# Assign time to a variable
time <- as.vector(sample_data(FCNA.scaled)$DateContinuous)

# Combine the otu table with ParMC
train <- cbind(ParMC,t_otu,time)
dim(train)

# Remove the NA rows
NA_idx <- is.na(ParMC)
train_noNA <- subset(train,!NA_idx)

# Lastly, remove the OTUs that are now all zeros 
zero_otus_idx <- which(colSums(train_noNA[,-1])==0)
train_noNA<-train_noNA[,-zero_otus_idx]
dim(train_noNA)
```

```{r}

# Make an NMDS colored by particulate microcystin lvels 
# Plot NMDS
bray.nmds = ordinate(FCNA.pruned,method="PCoA","bray")
plot_ordination(FCNA.pruned,bray.nmds,color = "ParMC") +
  geom_point(size=3) + 
  ggtitle("Full Community beta diversity and Microcystin levels") +
  scale_colour_gradient(name="Particulate \nmicrocystin (log)",
                        trans="log2",low="green", high="red") 


```


### results
```{r}
# It is important to set a seed for reproducability
# By default, randomForest uses p/3 variables when building 
# a random forest of regression trees and root(p) 
# variables when building a random forest of classification trees. 
# In this case, p/3 = 163
set.seed(2)
rf.mc <- randomForest(ParMC~.,data=train_noNA,ntree=100,keep.inbag = T)
print(rf.mc)

```

It looks like this model has a test Mean squared error of 32.6 and is able to explain half of the variation in Microcystin among the samples

```{r}
names(rf.mc)

```


### plots
```{r}
# Select the importance vactor for the predictors. 
# For a regression tree this is measured by mean decrease in MSE 
# due to that variable
imp <- importance(rf.mc)
imp <- data.frame(predictors=rownames(imp),imp)

# Order the predictor levels by importance
imp.sort <- arrange(imp,desc(IncNodePurity))
imp.sort$predictors <- factor(imp.sort$predictors,levels=imp.sort$predictors)

# Select the top 10 predictors
imp.10 <- imp.sort[1:10,]

# ggplot
ggplot(imp.10,aes(x=predictors,y=IncNodePurity))+
  geom_bar(stat="identity",fill="indianred") + 
  coord_flip()+
  ggtitle("Most important OTUs for predicting \n microcystin level of Lake Erie samples") + 
  ylab("mean decrease in MSE")

```

```{r}
# What are those OTUs?
otunames<- imp.10$predictors
r <- rownames(tax_table(FCNA)) %in% otunames
kable(tax_table(FCNA)[r,])
```



This is really interesting. Its telling us that the presence of pseudoanabena is the best predictor of toxicity. From other data we have, we know that psudoanabena only blooms in the later part of the season when Microcystis abundance is still high but toxin levels are much lower. There could be an interesting ecological interaction going on between microcystis and psuedoanabena which may relate to toxin production. 



## Functions
Here are some functions that i used previously in the code

### scale_reads
```{r}
# scale reads to the smallest library size 
# using method in McMurdie and Holmes, Plos CompBio (2014)
scale_reads <- function(physeq,n){
  physeq.scale <- transform_sample_counts(physeq, function(x) {(n*x/sum(x))})
  otu_table(physeq.scale) = floor(otu_table(physeq.scale))
  physeq.scale = prune_taxa(taxa_sums(physeq.scale)>0,physeq.scale)
  return(physeq.scale)
}
```
### transform_and_melt
```{r}

# This function takes a phyloseq object, 
# agglomerates OTU's to the desired taxonomic rank, 
# prunes out OTUs below a certain relative proportion 
# in a sample (ie 1% ) and melts the phyloseq object into long format.
transform_and_melt<-function(physeq,taxrank,prune){
  
  # Agglomerate all otu's by phylum level
  physeq_phylum<-tax_glom(physeq,taxrank = "Phylum")

  # Create a new phyloseq object which removes taxa from each sample 
  # below the prune parameter 
  physeq_phylum.prune = transform_sample_counts(physeq_phylum, 
                                              function(x){x/sum(x)})
  otu_table(physeq_phylum.prune)[otu_table(physeq_phylum.prune)<prune] <- 0 
  physeq_phylum.prune  = prune_taxa(taxa_sums(physeq_phylum.prune)>0,
                                 physeq_phylum.prune)

  # Melt into long format and sort by samplenum and phylum
  physeq_phylum.long<-psmelt(physeq_phylum.prune)
  physeq_phylum.long<-arrange(physeq_phylum.long,Samplenum,Phylum)


  # Reorder factor levels for dates 
  physeq_phylum.long<-order_dates(physeq_phylum.long)
  
  # Reorder factor levers for stations
  physeq_phylum.long$Station <-factor(physeq_phylum.long$Station,
                                      levels=c("WE2","WE12","WE4"))
  return(physeq_phylum.long)
}
```
### make_tax_barplot
```{r}
# This function takes  a data frame in long format 
# (such as the output from transform_and_melt) and 
# produces a stacked barplot of community composition.   

make_tax_barplot<-function(df,x,tax,title,colors,xlab,ylab){
  ggplot(df,aes_string(x=x,y="Abundance",fill=tax)) +
        facet_wrap(~Station,scales="free")+
        geom_bar(stat="identity")+
        geom_bar(stat="identity",position="fill",colour="black",show_guide=FALSE)+ 
   scale_y_continuous(labels = percent_format())+ 
  scale_fill_manual(values = colors) + 
    theme(axis.title.x = element_text(size=16,face="bold"),
          axis.text.x = element_text(angle=50, colour = "black", vjust=1, hjust = 1, size=9),
          axis.text.y = element_text(colour = "black", size=9),
          axis.title.y = element_text(face="bold", size=16),
          plot.title = element_text(size = 18),
          legend.title = element_text(size=14),
          legend.text = element_text(size = 13),
          legend.position="right",
          strip.text.x = element_text(size=12, face="bold"),
          strip.text.y = element_text(size=12, face="bold"),
          strip.background = element_rect(colour="black"))+
    guides(fill = guide_legend(reverse= TRUE,keywidth=1,keyheight=1))+
    xlab(xlab)+
    ylab(ylab)+
    ggtitle(title)
        
}

```


