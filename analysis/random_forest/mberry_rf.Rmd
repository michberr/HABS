---
title: "Random Forest Modelling of the Lake Erie microbial community"
output:
  html_document:
    css: markdown.css
    toc: true
    fig.height: 10
    fig.width: 14
---

This is a demo of how to run regression and classification random forest models with microbial community composition datasets in R. Much of this code utilizes the [Phyloseq](http://joey711.github.io/phyloseq/) package. 
This page was created with 
[Rmarkdown](http://rmarkdown.rstudio.com/).

Author: Michelle Berry     
Date Created: 2/24/15         
Date Updated: 9/26/15

===================================================================


In this tutorial, we are working with illumina 16s data that has already been processed into an [OTU](https://en.wikipedia.org/wiki/Operational_taxonomic_unit) 
and taxonomy table from the 
[mothur](http://www.mothur.org/) pipeline. 
Phyloseq has a variety of 
[import](http://joey711.github.io/phyloseq/import-data) 
options if you processed your raw sequence data with a different pipeline.

The data used in this tutorial consists of water samples collected from the Western basin of Lake Erie between May and November 2014. The goal of this dataset was to understand how the bacterial community in Lake Erie shifts during toxic 
[algal blooms](http://www.glerl.noaa.gov/res/HABs_and_Hypoxia/) 
caused predominantly by a genus of cyanobacteria called [Microcystis](https://en.wikipedia.org/wiki/Microcystis). 
Water samples were fractionated to distinguish free-living bacteria, particle-associated bacteria, and larger colonies of blooming cyanobacteria.

# Libraries
```{r load libraries, warning = FALSE, message = FALSE}
#Load libraries
library(ggplot2)
library(vegan)
library(dplyr)
library(magrittr)
library(scales)
library(grid)
library(reshape2)
library(phyloseq)
```

```{r}
# Set working directory
setwd("~/chabs/miseq_may2015/analysis/")

# Source code files
# miseqR.R can be found in this repository
# habs_functions.R are formatting functions specific to this dataset
source("miseqR.R")
source("habs_functions.R")

# Because grey plots are ugly
theme_set(theme_bw())
```

# Data import

here we import the mothur shared file, consensus taxonomy file, 
and our sample metadata and store them in one phyloseq object
```{r mothur import}

# Import mothur files and sample metadata
sharedfile = "mothur/allhabs.shared"
taxfile = "mothur/allhabs.taxonomy"
mapfile = "other/habs_metadata.csv"
 
mothurdata = import_mothur(mothur_shared_file = sharedfile,
  mothur_constaxonomy_file = taxfile)

# Import sample metadata
map <- read.csv(mapfile)
map <- sample_data(map)
rownames(map) <- map$SampleID
  
# Merge mothurdata object with sample metadata
erie.merge <- merge_phyloseq(mothurdata, map)
erie.merge
```
Now we have a phyloseq object called erie.merge. 

Before we move on with analysis, we need to do some basic reformatting and filtering 
```{r}
#  I like to add the OTU number as a column in the taxonomy file
tax_table(erie.merge) <- cbind(tax_table(erie.merge), 
  row.names(tax_table(erie.merge)))

colnames(tax_table(erie.merge))
# These taxonomy names are not helpful, so let's rename them
colnames(tax_table(erie.merge)) <- c("Kingdom", "Phylum", "Class",
  "Order", "Family", "Genus", "Species")
  
# Filter out non-samples (i.e. water, mock, blanks) 
# Note, there is a column in my metadata named "Type"
# Also prune out taxa which were only present in removed samples
erie <- subset_samples(erie.merge, Type == "sample")
erie <- prune_taxa(taxa_sums(erie) > 0, erie)

# Filter out non-bacteria, chloroplasts and mitochondria 
# You may have done this already in mothur, but it's good to check
erie %>%
  subset_taxa(Kingdom == "Bacteria" & 
              Family != "mitochondria" & 
              Class != "Chloroplast") -> erie

erie
```

## Classification rf: modelling algal-associated vs free-living

For this random forest we want to build a model which will classify samples as either "free-living" or "algal/particle". In doing this, we will also pull out which OTUs seem to be associated with the free-living lifestyle, vs attachment to colonial algae

First, we need to do a few things to filter our data and put it in the right format.
The first step is to subset our samples to just the free-living and algal/particle-associated 
algae. Next, we scale our reads by normalizing to our smallest library size
```{r}
# Select only samples of type 100L (Algal/particle) or 22NA (free-living)
erie %>%
  subset_samples(Fraction %in% c("100LTR", "22NA")) %>%
  scale_reads(round = "round") -> fraction.scale        

```

Lets make some barplots to get a sense of what these communities look like. Here are some barplots of phylum composition from all three locations (WE2, WE12, WE4)

```{r fig.height=8, fig.width=12, message=FALSE, error=FALSE}

# Subset to colonial fraction, glom at phylum level, prune out taxa < 2%, and format
erie %>%
  subset_samples(Fraction == "100LTR") %>%
  taxglom_and_melt(taxrank = "Phylum", prune = 0.02) %>%
  habs_format() -> colonies

# Set Colors (RColorBrewer)
phy <- c(Acidobacteria="#4D4D4D", Actinobacteria="#ff7f00", 
         Armatimonadetes="#ffff99", Bacteroidetes="#6a3d9a", 
         Candidate_division_SR1 ="#b15928", Chlorobi="#cab2d6",
         Chloroflexi="#B2DF8A", Cyanobacteria="#33A02C",
         Gemmatimonadetes="#fdbf6f", Planctomycetes="#A6CEE3",
         Proteobacteria="#1F78B4", unclassified="#fb9a99", 
         Verrucomicrobia ="#e31a1c") 

# Plot 
ggplot(colonies, aes(x = Date, y = Abundance, fill = Phylum)) + 
  facet_grid(Station~., scales = "free_y") +
  geom_bar(stat = "identity") +
  geom_bar(
    stat = "identity", 
    position = "fill", 
    colour = "black", 
    show_guide = FALSE
  ) + 
  scale_fill_manual(values = phy) +
  scale_x_discrete(
    breaks = c("6/10", "7/8", "8/4", "9/2", "10/6", "11/3"),
    labels = c("Jun", "Jul", "Aug", "Sep", "Oct", "Nov"), 
    drop = FALSE
  ) + 
  stackbar_theme +
  guides(fill = guide_legend(reverse = TRUE, keywidth = 1, keyheight = 1)) +
  xlab("") +
  ylab("Relative Abundance (Phyla > 2%) \n") +
  ggtitle("Phylum composition of algal colony fraction of Lake Erie \n
          bacterial community at three sites \n") 



```

```{r fig.height=8, fig.width=12, message=FALSE, error=FALSE}

# subset to just free-living (3-0.22um) fraction, glom at phylum level,
# prune out taxa < 2% and format
erie %>%
  subset_samples(Fraction == "22NA") %>%
  taxglom_and_melt(taxrank = "Phylum", prune = 0.02) %>%
  habs_format() -> free

ggplot(free, aes(x = Date, y = Abundance, fill = Phylum)) + 
  facet_grid(Station~., scales = "free_y") +
  geom_bar(stat = "identity") +
  geom_bar(
    stat = "identity", 
    position = "fill", 
    colour = "black", 
    show_guide = FALSE
  ) + 
  scale_fill_manual(values = phy) +
  scale_x_discrete(
    breaks = c("6/10", "7/8", "8/4", "9/2", "10/6", "11/3"),
    labels = c("Jun", "Jul", "Aug", "Sep", "Oct", "Nov"), 
    drop = FALSE
  ) + 
  stackbar_theme +
  guides(fill = guide_legend(reverse = TRUE, keywidth = 1, keyheight = 1)) +
  xlab("") +
  ylab("Relative Abundance (Phyla > 2%) \n") +
  ggtitle("Phylum composition of free-living fraction of Lake Erie \n
          bacterial community at three sites \n") 


```

Here is an NMDS of the samples colored by free-living or particle/algal. We can already see that these communities are very well segregated, so our random forest model will probably work very well. 

```{r}

# NMDS scores using bray-curtis distance 
bray.nmds <- ordinate(physeq = fraction, method = "NMDS", distance = "bray")

# Plot NMDS and color samples by filter fraction
plot_ordination(physeq = fraction, ordination = bray.nmds, color = "Fraction") + 
  geom_point(size = 3) + 
  ggtitle("Free-living and Particle/Algal bacterial communities")

```



```{r}
# Make a dataframe of training data with OTUs as column and samples as rows
t_otu <- t(otu_table(fraction.scale))
dim(t_otu)
```
We have `r nrow(t_otu)` samples and `r ncol(t_otu)` OTUs
```{r}
# Make one column for our predictor variable "Fraction"
Fraction <- as.factor(sample_data(fraction.scale)$Fraction)

# Combine them into 1 data frame
rf_data <- data.frame(Fraction, t_otu)

```


Now we will use the randomForest package to train and test our random forest model using the "out of bag" error to estimate our model error. OOB is a nice feature of random forest models whereby since the training data is bootstrapped, you only use approximately 2/3 of the data at each iteration. The remaining 1/3 or "out of bag" data can be used to validate your model. This removes the need to use another form of cross-validation such as using a separate validation set or k-folds.     

It is important to set a seed for reproducability
By default, randomForest uses p/3 variables when building 
a random forest of regression trees and root(p) 
variables when building a random forest of classification trees. 
In this case, root(p) = `r (ncol(t_otu))^.5`

### Results
```{r}
set.seed(1)
erie.classify <- randomForest(Fraction~., data = rf_data, ntree=100)
print(erie.classify)
```
Our out of bag error is 1.65%

```{r}
# What variables are stored in the output?
names(erie.classify)

```
This model worked really well! We can very accurately classify our bacterial communities into free-living or particle/algal-associated


### plots 
Lets make some plots of the most important variables in our model
```{r}
# Select the importance vactor for the predictors. 
# For a regression tree this is measured by mean decrease in MSE 
# due to that variable
imp <- importance(erie.classify)
imp <- data.frame(predictors = rownames(imp), imp)

# Order the predictor levels by importance
imp.sort <- arrange(imp, desc(MeanDecreaseGini))
imp.sort$predictors <- factor(imp.sort$predictors, levels = imp.sort$predictors)

# Select the top 10 predictors
imp.10 <- imp.sort[1:10, ]


# ggplot
ggplot(imp.10, aes(x = predictors, y = MeanDecreaseGini)) +
  geom_bar(stat = "identity", fill = "indianred") +
  coord_flip() +
  ggtitle("Most important OTUs for classifying Erie samples \n
          into free-living or algal-associated")

# What are those OTUs?
otunames <- imp.10$predictors
r <- rownames(tax_table(fraction.scale)) %in% otunames
kable(tax_table(fraction.scale)[r, ])
```

## Regression rf: modelling microcystin levels 

In this random forest we will attempt to predict microcystin toxin levels using geochemical data as predictors. This model will not incorporate our ecological data, but you could easily implement a model that included ecological count data as either a set of predictors or as a response variable. 


```{r}

# Subset the data to select just full community samples
#erie %>%
  #subset_samples(Fraction == "CNA") %>%
  #scale_reads(round = "round") -> Full.scaled

```

This is a large number of OTUs, so to speed up the model a bit we will remove all rare OTUs that are probably not very biologically relevant

```{r include=FALSE}
n = 15000
thresh = 0.0001

# Prune low abundance taxa
tax_mean <- taxa_sums(Full.scaled)/nsamples(Full.scaled)
Full.pruned <- prune_taxa(tax_mean > thresh*n, Full.scaled)

```
Now we only have 488 OTUs to put into our model 

```{r, include=FALSE}
# Make a dataframe with OTUs as columns, samples as rows, 
# and one column for our predictor variable "Microcystin"
t_otu <- t(otu_table(Full.pruned))
dim(t_otu)
# We have 62 samples and 423 OTUs

# Select abiotic factors to include in model
sampdat <- data.frame(sample_data(Full.pruned))

sampdat %>%
  select(pH, Secchi, Temp, Turbidity, SRP, POC,
         Nitrate, Ammonia, H2O2, Chla, ParMC, Phycocyanin) %>%
  na.omit() -> abiotic



# Combine the otu table with abiotic predictors and outcome (toxin)
train <- merge(t_otu, abiotic, by="row.names")
dim(train)
train <- train[ ,-1]


# Lastly, remove the OTUs that are now all zeros 
zero_otus_idx <- which(colSums(train_noNA[,-1]) == 0)
train_noNA<-train_noNA[,-zero_otus_idx]
dim(train_noNA)
```

```{r include=FALSE}

# Make a PCoA colored by particulate microcystin levels 
bray.nmds = ordinate(physeq = Full.pruned, method = "PCoA", distance = "bray")

# Plot PCoA
plot_ordination(physeq = Full.pruned, ordination = bray.nmds, color = "ParMC") +
  geom_point(size=3) + 
  ggtitle("Full Community beta diversity and Microcystin levels") +
  scale_colour_gradient(name="Particulate \nmicrocystin (log)",
                        trans="log2",low="green", high="red") 


```


### results

It is important to set a seed for reproducability
By default, randomForest uses p/3 variables when building 
a random forest of regression trees and root(p) 
variables when building a random forest of classification trees. 
In this case, p/3 = 163
```{r include=FALSE}
set.seed(2)
rf.mc <- randomForest(ParMC~., data = train, ntree = 500, keep.inbag = T)
print(rf.mc)

```

It looks like this model has a test Mean squared error of 32.6 and is able to explain half of the variation in Microcystin among the samples

```{r include=FALSE}
names(rf.mc)

```


### plots
```{r include = FALSE}
# Select the importance vactor for the predictors. 
# For a regression tree this is measured by mean decrease in MSE 
# due to that variable
imp <- importance(rf.mc)
imp <- data.frame(predictors = rownames(imp), imp)

# Order the predictor levels by importance
imp.sort <- arrange(imp,desc(IncNodePurity))
imp.sort$predictors <- factor(imp.sort$predictors, levels = imp.sort$predictors)

# Select the top 10 predictors
imp.10 <- imp.sort[1:40, ]

# ggplot
ggplot(imp.10, aes(x = predictors, y = IncNodePurity)) +
  geom_bar(stat="identity", fill="indianred") + 
  coord_flip() +
  ggtitle("Most important factors for predicting \n microcystin level of Lake Erie samples") + 
  ylab("mean decrease in MSE")

```

```{r include=FALSE}
# What are those OTUs?
otunames<- imp.10$predictors
r <- rownames(tax_table(Full.scaled)) %in% otunames
kable(tax_table(Full.scaled)[r, ])
```



This is really interesting. Its telling us that the presence of pseudoanabena is the best predictor of toxicity. From other data we have, we know that pseudoanabena only blooms in the later part of the season when Microcystis abundance is still high but toxin levels are much lower. There could be an interesting ecological interaction going on between microcystis and psuedoanabena which may relate to toxin production. 



