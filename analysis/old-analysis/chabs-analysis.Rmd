---
title: 'Lake Erie HABs Community Ecology Manuscript'
output:
  html_document:
    toc: true
    toc_float: true
    code_folding: show
    
---
    

```{r global_options, echo = FALSE}

knitr::opts_chunk$set(
  fig.align = 'center', 
  fig.path = 'Figs/',
  warning = FALSE, 
  message = FALSE,
  dev = c('pdf', 'postscript')
)

```

# Load libraries
```{r load libraries, warning=FALSE}
library(phyloseq)
library(ggplot2)
library(dplyr)
library(scales)
library(grid)
library(reshape2)
library(gridExtra)
library(vegan)
library(cowplot)
library(gtable)
library(pander)
library(tidyr)
library(DT)

```

# Global
```{r}
## objects and functions that will be useful throughout this analysis

# Set the ggplot theme
theme_set(theme_bw())

# Color palette for stations
station_colors = c("red", "#ffa500", "#0080ff")

# Function to order date levels correctly
order_dates <- function(df) {
  df$Date <- factor(df$Date, 
    levels = c("6/16","6/30","7/8","7/14","7/21",
      "7/29","8/4","8/11","8/18","8/25","9/2","9/8","9/15",
      "9/23","9/29","10/6","10/15","10/20","10/27"))
  return(df)
}

named_list <- function(...){
    names <- as.list(substitute(list(...)))[-1L]
    result <- list(...)
    names(result) <- names
    result
}

# Source some useful functions for data normalizatio
source("~/git_repos/MicrobeMiseq/R/miseqR.R")
```

# Load Data
```{r phyloseq import}
load("data/erie-data.RData")

# Inspect erie phyloseq object
erie
```


# Normalization
```{r normalization}

## Scale reads in OTU table to even depth 
depth = 15000

erie_scale <- 
  erie %>%
    scale_reads(n = depth, round = "round") 

## Variance stabilize reads 

```

# Figure 1: Bloom temporal dynamics


```{r figure1, fig.height=6, fig.width=6}

# Import metadata file with nutrients, pigments and toxin
nutrient <- read.csv("data/nutrient_cleaned.csv")

# Format nutrient data
nutrient_sub <- 
  nutrient %>%
    filter(!(Date %in% c("5/27", "6/10", "11/3"))) %>%
    order_dates() 

# Calculate relative abundance of Cyanobacteria at each date
cyano_abundance <- 
  erie_scale %>%
    tax_glom(taxrank = "Phylum") %>%                        # conglomerate OTUs to phylum level
    transform_sample_counts(function(x) {x/sum(x)} ) %>%    # transform to relative abundance
    subset_taxa(Phylum == "Cyanobacteria") %>%              # Subset to just Cyanobacteria
    psmelt() %>%                                            # melt phyloseq object
    rename(Cyanobacteria = Abundance) %>%
    select(Cyanobacteria, Date, Station)

# Merge cyanobacteria data with nutrient df
bloom_df <- 
  nutrient_sub %>%
    left_join(cyano_abundance, by = c("Station", "Date")) %>%
    mutate(Phycocyanin = ifelse(Phycocyanin > 80, 80, Phycocyanin)) %>%   # lower extreme values to plot better
    select(Station, Date, Phycocyanin, Chla, ParMC, Cyanobacteria) %>%
    melt(id.vars = c("Station", "Date")) %>%
    order_dates()

# Make a faceted ggplot of the four bloom variables over time and grouped by station
bloom_plots <- ggplot(bloom_df, 
  aes(x = Date, y = value, group = Station, color = Station, shape = Station)
) +
  facet_grid(variable~., scales = "free_y") +
  geom_point(size = 1.3) +
  geom_line(size = 1) + 
  ylab("") +
  scale_x_discrete(
    breaks = c("7/8", "8/4", "9/2", "10/6"),
    labels = c("Jul", "Aug", "Sep", "Oct"),
    drop = FALSE
  ) +
  scale_color_manual(values = station_colors) + 
  theme(
    strip.background = element_blank(),
    strip.text = element_text(size = 11),
    axis.title.x = element_blank()
  )

# function to extract a legend from a ggplot object
grab_legend <- function(a_ggplot) {
    tmp <- ggplot_gtable(ggplot_build(a_ggplot))
    leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
    legend <- tmp$grobs[[leg]]
    legend
}

station_legend <- grab_legend(bloom_plots) 

bloom_plots
```

## Figure 1 Statistics
Correlations between chl a and phycocyanin
```{r figure1stats}

hist(nutrient$Chla)
hist(nutrient$Phycocyanin)

# Calculate correlation between Chla and phycocyanin for all sites
cor.test(
  x = nutrient$Chla, 
  y = nutrient$Phycocyanin, 
  alternative = "greater", 
  method = "spearman"
)


# normalize by log scaling 

hist(log(nutrient$Chla))
hist(log(nutrient$Phycocyanin))

# Calculate correlation between Chla and phycocyanin for all sites
# Remove data point 57 which is 0
cor.test(
  x = log(nutrient$Chla[1:56]), 
  y = log(nutrient$Phycocyanin[1:56]), 
  alternative = "greater", 
  method = "pearson"
)

```

# Figure 2: Cyano OTUs
  
The goal of this code is to generate lineplots for each non-rare
(rel abundance > 0.0001) cyanobacterial OTU
```{r, fig.height=8, fig.width=8}

# Function to make a ggplot lineplot of an OTU's relative abundance over time
#
# Args:
#   df: a melted data frame generated by calling psmelt() on a phyloseq object. 
#       Contains an "Abundance" column for the OTU's abundance 
#   otu: the OTU to generate a lineplot for
#   taxrank: the taxonomic rank to appear in the plot title (e.g. "Genus")
# Returns:
#   a ggplot lineplot
plot_otus <- function(df, otu, taxrank) {
  ggplot(df, 
    aes(x = Date, y = Abundance, group = Station, color = Station, shape = Station)) +
    geom_point(size = 2) +
    geom_line(size = 0.7) +
    ggtitle(paste(df[1, taxrank], otu)) +
    ylab("rel. abund") + 
    scale_color_manual(values = station_colors) +
    scale_x_discrete(
      breaks = c("7/8", "8/4", "9/2", "10/6"),
      labels = c("Jul", "Aug", "Sep", "Oct"),
      drop = FALSE
    ) +
    theme(
      axis.title.x = element_blank(),
      axis.title.y = element_text(size = 9),
      legend.position = "none",
      plot.title = element_text(size = 10, face = "bold")
    ) 
}

## Select only cyano OTUs that have mean relative abundace > 0.0001
n = 15000
thresh = 0.0001

# Calculate mean relative abundance for each OTU
tax_mean <- taxa_sums(erie_scale)/nsamples(erie_scale)

# Prune low abundance taxa using thresh as mean relative abundance
erie_prune_0001 <- 
  erie_scale %>%
    prune_taxa(tax_mean > thresh*n, .)


# Create a melted data frame of selected cyanobacteria OTUs
cyano_otus <- 
  erie_prune_0001 %>%
    transform_sample_counts(function(x) {x/sum(x)}) %>%
    subset_taxa(Class == "Cyanobacteria") %>%
    psmelt() %>%
    order_dates()

cyano_otu_names <- as.list(levels(cyano_otus$Species))
names(cyano_otu_names) <- levels(cyano_otus$Species)


# Generate a lineplot for each cyanobacteria with mean relative abundance > 0.0001
cyano_otu_plots <- lapply(cyano_otu_names, 
  function(otu) {
    df_otu <- filter(cyano_otus, OTU == otu)
    plot <- plot_otus(df = df_otu, otu = otu, taxrank = "Genus") 
    return(plot)
  }
)


##################### Compile plots #####################################

grid.arrange(
  cyano_otu_plots$Otu00007, cyano_otu_plots$Otu00037, cyano_otu_plots$Otu00005,
  cyano_otu_plots$Otu00044, cyano_otu_plots$Otu00063, cyano_otu_plots$Otu00049,
  cyano_otu_plots$Otu00147, cyano_otu_plots$Otu00193, cyano_otu_plots$Otu00304,
  cyano_otu_plots$Otu00177, station_legend,           cyano_otu_plots$Otu00403, 
  ncol = 3
)



```


# Figure 3: Alpha diversity

```{r}

# My own subsetting function, similar to phyloseq::subset_taxa, except taxa can 
# be passed as arguments within functions without weird environment errors
#
# Args:
#   physeq: a phyloseq object
#   taxrank: taxonomic rank to filter on
#   taxa: a vector of taxa groups to filter on
#
# Returns: 
#   a phyloseq object subsetted to the x taxa in taxrank
my_subset_taxa <- function(physeq, taxrank, taxa) {
  physeq_tax_sub <- tax_table(physeq)[tax_table(physeq)[ , taxrank] %in% taxa, ]
  tax_table(physeq) <- physeq_tax_sub
  return(physeq)
}

```

```{r, cache = TRUE}
# Initialize parameters
trials = 100
min_lib = 15000 # Depth we are rarefying to

# Groups to estimate alpha diversity for 
mytaxa <- c("Bacteria", "NcBacteria", "Actinobacteria", "Alphaproteobacteria", "Betaproteobacteria", 
            "Bacteroidetes", "Gammaproteobacteria", "Deltaproteobacteria", "Verrucomicrobia")
names(mytaxa) <- mytaxa

# Taxonomic ranks of mytaxa
mytaxa_taxrank <- c("Kingdom", "Class", "Phylum", "Class", "Class", "Phylum", "Class", "Class", "Phylum")
names(mytaxa_taxrank) <- mytaxa

# Data frame to hold alpha diversity estimates over trials
alphadiv_df <- data.frame(matrix(nrow = nsamples(erie), ncol = trials))

# Initialize empty df's for richness and evenness of all taxa in mytaxa
richness <- lapply(mytaxa, function(x) {return(alphadiv_df)} )
inv_simpson <- lapply(mytaxa, function(x) {return(alphadiv_df)} )

alphadiv_list <- list(richness = richness, inv_simpson = inv_simpson)


# It is always important to set a seed when you subsample so your result is replicable 
set.seed(3)

# Run trials to subsample and estimate diversity
for (i in 1:trials) {
  # Subsample
  rarefied_physeq <- rarefy_even_depth(erie, sample.size = min_lib, verbose = FALSE, replace = TRUE)
  
  # Generate alpha-diversity estimates for each taxonomic group
  for (t in mytaxa) {
    # Subset physeq object to taxa in mytaxa
    if (t != "NcBacteria") {
      physeq_sub <- my_subset_taxa(
        physeq = rarefied_physeq, 
        taxrank = mytaxa_taxrank[t], 
        taxa = t
      )
    } else {
      physeq_sub <- subset_taxa(physeq = rarefied_physeq, Class != "Cyanobacteria")
    }
    
    # Calculate observed richness for that group and store value in a df column
    alphadiv_list$richness[[t]][ ,i] <- estimate_richness(physeq_sub, measures = "Observed")[ ,1]
     
    # Calculate Inv. Simpson for that group and store value in a df column
    alphadiv_list$inv_simpson[[t]][ ,i] <- estimate_richness(physeq_sub, measures = "InvSimpson")[ ,1]

  }
}
  
```


```{r}

# Calculate the means of richness and inverse simpson from the 100 trials
alphadiv_est <- lapply(alphadiv_list, function(div_measure) {
    lapply(div_measure, function(taxa_group) {
        alpha_mean <- rowMeans(taxa_group)
        return(alpha_mean)
    })  
})

# Convert alphadiv_est richness and inv_simpsons lists into wide data frames
l <- lapply(alphadiv_est, function(x) {
  # convert from list to data.frame
  est_df <- plyr::ldply(.data = x, .fun = data.frame)
  names(est_df) <- c("Taxa", "Diversity")
  
  # Add in SampleID column and spread to wide format
  r <- est_df %>%
    mutate(SampleID = rep(sample_names(erie), length(mytaxa)))
  return(r)
})

# Merge sample metadata with these estimates
chla_dat <- data.frame(sample_data(erie)) %>%
  select(SampleID, Chla, Station, Date, Days)

# Create a df with a "Diversity" column that includes richness and inv. simpson,
# and log-chl a values from erie sample_data
alpha_comb <- l$richness %>% 
  left_join(y = l$inv_simpson, by = c("Taxa", "SampleID")) %>%  # Join the richness and inv_simp df's
  rename(Richness = Diversity.x, InvSimpson = Diversity.y) %>%  # rename columns to avoid confusion
  left_join(chla_dat, by = "SampleID") %>%                      # Join with chla data
  mutate(logChla = log(Chla)) %>%
  gather(key = "Alphadiv", value = "Estimate", Richness, InvSimpson) %>%
  order_dates()


```

```{r}

# Function to test whether there is a linear relationship 
# between log chla and alpha diversity of a group
#
# Args:
#   df: a data frame with a column called logChla and value
#
# Returns:
#   a vector with the pvalue and R2 of the linear model
test_alphadiv_pp <- function(df) {
  
  df_sub <- 
    df %>% 
      select(logChla, Estimate) %>%
      na.omit()
  
  # Fit a linear model 
  fit <- lm(Estimate ~ logChla, data = df_sub)
  
  # Grab model outputs
  fit_pvalue <- summary(fit)$coef[2,4]
  fit_r2 <- summary(fit)$r.squared
  
  return(c(fit_pvalue, fit_r2))
}

divs <- named_list("Richness", "InvSimpson")

# apply alpha div test to each diversity index for each group
alpha_models <- lapply(divs, function(d) {
  alpha_sub <- alpha_comb %>% filter(Alphadiv == d)
  lapply(mytaxa, function(t) {
    alpha_sub <- alpha_sub %>% filter(Taxa == t)
    # Fit linear model 
    fit <- test_alphadiv_pp(alpha_sub)
    return(fit)
  })
})

# Unlist richness
alpha_results <- lapply(alpha_models, function(x) {
  f <- x %>% 
     unlist(use.names = FALSE) %>%
     matrix(
        nrow = length(mytaxa), 
        ncol = 2, 
        byrow = TRUE, 
        dimnames = list(mytaxa, c("pvalue","r2"))
    )
    
  # fdr correction on pvalues
  f[ ,1] <- p.adjust(f[ ,1], method = "fdr") 
  # Round to three significant digits
  f <- round(f, digits = 3)
})

```

```{r fig.height=7, fig.width=13}

# Function to make a ggplot scatterplot of logChla vs an alpha-diversity metric.
# If the pvalue is below 0.05, it will also plot the fitted line
#
# Args:
#   df: a melted data frame with a column called logChla and value for alpha-diversity
#   measure: Alpha-diversity measure (e.g. "InvSimpson" or "Observed")
#   group: Taxonomic group to plot (e.g. "Betaproteobacteria")
#   pvalue: pvalue from linear model returned by test_alphadiv_pp
#   r2: r2 from linear model returned by test_alphadiv_pp
#
# Returns:
#   a ggplot
make_alphadiv_plot <- function(df, measure, group, pvalue, r2) {
  
  g <- ggplot(df, aes(x = logChla, y = Estimate)) + 
    geom_point() +
    ylab(measure) +
    ggtitle(group) 
  
  # Since we rounded to 3 sigfigs, pEstimates of 0 need to actually say "p < 0.001"
  if (pvalue != 0) {
    g <- g + annotate(
      "text", 
      x = 1,
      y = max(df$Estimate) - 0.03*max(df$Estimate), 
      size = 3, 
      label = paste("p =", pvalue)
      )
  } else {
    g <- g + annotate(
      "text", 
      x = 1,
      y = max(df$Estimate) - 0.03*max(df$Estimate), 
      size = 3, 
      label = "p < 0.001"
      )
  }
  
  if (pvalue < 0.05) {
    g <- g + annotate(
      "text",
      x = 1,
      y = max(df$Estimate) - 0.08*max(df$Estimate),
      size = 3,
      label = paste("R2 =", r2)
    ) + geom_smooth(method = "lm", size = 1)
  }
  
  return(g)
                     
}

## Make plots for inverse simpson index vs log chla
simp_plots <- list()

for (i in 1:length(mytaxa)) {
  df <- filter(alpha_comb, Taxa == mytaxa[i]) %>%
    filter(Alphadiv == "InvSimpson")
  simp_plots[[i]] <- make_alphadiv_plot(
    df = df, 
    measure = "InvSimpson", 
    group = mytaxa[i],
    pvalue = alpha_results$InvSimpson[i, 1],
    r2 = alpha_results$InvSimpson[i, 2]
  )
}


## Make plots for observed richness vs log chla
obs_plots <- list()

for (i in 1:length(mytaxa)) {
  df <- filter(alpha_comb, Taxa == mytaxa[i]) %>%
    filter(Alphadiv == "Richness")
  obs_plots[[i]] <- make_alphadiv_plot(
    df = df, 
    measure = "Richness", 
    group = mytaxa[i],
    pvalue = alpha_results$Richness[i, 1],
    r2 = alpha_results$Richness[i, 2]
  )
}

## Arrange plots for final figure
grid.arrange(obs_plots[[2]],  obs_plots[[4]],  obs_plots[[5]],  obs_plots[[6]], 
             simp_plots[[2]], simp_plots[[4]], simp_plots[[5]], simp_plots[[6]],
             ncol = 4)

```

# Figure 4: PCoA analyses

## PCoA ordination plots

```{r}

# Subset to cyanobacteria and scale internally
cyanos <- 
  erie %>%
    subset_taxa(Class == "Cyanobacteria") %>%
    scale_reads(round = "round")


# Subset to cyanobacteria and scale internally
non_cyanos <- 
  erie %>%
    subset_taxa(Class != "Cyanobacteria") %>%
    scale_reads(round = "round")

# Make a list of phyloseq objects for the full community, cyanos, and non-cyanos
physeq_subsets <- list(erie_scale, cyanos, non_cyanos)
names(physeq_subsets) <- c("full", "Cyanobacteria", "NcBacteria")


# Generate pcoa scores for each subset
pcoas <- lapply(physeq_subsets, 
  function(x) {
    ordinate(
      physeq = x,
      method = "PCoA",
      distance = "bray"
    )
  }
)


# Generate a df to plot pcoa for each subset
pcoa_dfs <- lapply(pcoas,
  function(x, names) {
    p <- plot_ordination(
      physeq = erie_scale,
      axes = 1:3,
      ordination = x,
      justDF = TRUE
    )
    p$Month <- factor(p$Month, 
      levels = c("June", "July", "August", "September", "October"))
    p <- p %>% 
      rename(PC1 = Axis.1, PC2 = Axis.2, PC3 = Axis.3) %>%
      order_dates()
    return(p)
  }
)

# Flip orientation of PC2 for Cyanobacteria (does not affect interpretation)
pcoa_dfs$NcBacteria$PC2 <- -pcoa_dfs$NcBacteria$PC2

# Generate relative, lingoes-corrected eigenvalues for PC1 and PC2
eigs <- lapply(pcoas,
  function(x) {
    pcs <- c(PC1 = signif(x$values$Rel_corr_eig[1]*100, 3),
             PC2 = signif(x$values$Rel_corr_eig[2]*100, 3),
             PC3 = signif(x$values$Rel_corr_eig[3]*100, 3)
            )
    return(pcs)
  }
)


pcoa_plots <- Map(
  function(x, n) {
    ggplot(data = x, aes(x = PC1, y = PC2, 
           color = Station, shape = Station)) +
      geom_point(aes(alpha = Month), size = 2.5) + 
      scale_color_manual(values = station_colors) + 
      xlab(paste("PC1 ", eigs[[n]][1], "%")) +
      ylab(paste("PC2 ", eigs[[n]][2], "%")) +
      theme(plot.margin = unit(c(0, 0.2, 0, 0.2), "cm"))
  }, 
  pcoa_dfs, names(pcoa_dfs)
)

    
# Extract legend
pcoa_legend <- grab_legend(pcoa_plots$full)

# Remove legend from plots
pcoa_plots <- lapply(pcoa_plots, 
  function(x) {x + theme(legend.position = "none")}
)


```

```{r}

n = 15000
thresh = 0.0001

# Calculate mean relative abundance for each OTU
tax_mean <- taxa_sums(non_cyanos)/nsamples(non_cyanos)

# Prune low abundance taxa using thresh as mean relative abundance
nc_prune <- 
  non_cyanos %>%
    prune_taxa(tax_mean > thresh*n, .)

Species <- tax_table(nc_prune)[,"Species"]

cors <- list()

for (species in Species) {
  otu_abun <- as.numeric(otu_table(nc_prune)[species, ])
  cors[[species]] <- cor.test(otu_abun, pcoa_dfs$NcBacteria$PC1, method = "pearson")
}

p_values <- lapply(cors, function(x) {x$p.value})

w <- which(unlist(p_values) < (0.01/385))

r_values <- lapply(cors, function(x) {
  y <- x$estimate
  names(y) <- NULL
  return(y)
})

pos <- which(unlist(r_values) > 0)
neg <- which(unlist(r_values) < 0)

pc1_pos_taxa <- intersect(names(w), names(pos))

pc1_neg_taxa <- intersect(names(w), names(neg))

pc1_postax_table <- tax_table(erie)[pc1_pos_taxa,]
pc1_negtax_table <- tax_table(erie)[pc1_neg_taxa,]

p1 <- plot(pcoa_dfs$NcBacteria$PC1, as.numeric(otu_table(nc_prune)["Otu00002",]), xlab = "PC1 score", ylab = "Otu00002 LHab A1", main = paste("r:", round(cors$Otu00002$estimate,2)))

p2 <- plot(pcoa_dfs$NcBacteria$PC1, as.numeric(otu_table(nc_prune)["Otu00004",]),xlab = "PC1 score", ylab = "Otu00004 acI-B", main = paste("r:", round(cors$Otu00004$estimate,2)))
p3 <- plot(pcoa_dfs$NcBacteria$PC1, as.numeric(otu_table(nc_prune)["Otu00006",]),xlab = "PC1 score", ylab = "Otu00006 acI-C", main = paste("r:", round(cors$Otu00006$estimate,2)))
p4 <- plot(pcoa_dfs$NcBacteria$PC1, as.numeric(otu_table(nc_prune)["Otu00011",]),xlab = "PC1 score", ylab = "Otu00011 acI-A", main = paste("r:", round(cors$Otu00011$estimate,2)))

p5 <- plot(pcoa_dfs$NcBacteria$PC1, as.numeric(otu_table(nc_prune)["Otu00075",]),
xlab = "PC1 score", ylab = "Otu00075 alfII-A", main = paste("r:", round(cors$Otu00075$estimate,2)))

p6 <- plot(pcoa_dfs$NcBacteria$PC1, as.numeric(otu_table(nc_prune)["Otu00073",]),xlab = "PC1 score", ylab = "Otu00073 Planctomyces", main = paste("r:", round(cors$Otu00073$estimate,2)))

par(mfrow = c(2,3))
```

## PCoA time series plots

which PC's exceed the broken stick model for cyanos?
```{r}
which(
  pcoas$Cyanobacteria$values$Rel_corr_eig > 
  pcoas$Cyanobacteria$values$Broken_stick
)
```
We will inspect PC1 and PC2 for cyanobacteria
        
which PC's exceed the broken stick model for nc-bacteria?
```{r}
# Determine which PC's exceed broken stick model for nc-bacteria
which(
  pcoas$NcBacteria$values$Rel_corr_eig > 
  pcoas$NcBacteria$values$Broken_stick
)
```
We will inspect PC1, PC2, and PC3 for nc-bacteria

```{r}

# Function to create a plot of time (x-axis) vs PC scores (y-axis)
plot_pcts <- function(df, pc, eigs) {
  ggplot(df, 
    aes_string(x = "Date", y = pc, group = "Station", color = "Station", shape = "Station")) +
      geom_point(size = 2.5) +
      geom_line(size = 1.1) + 
      scale_color_manual(values = station_colors) +
      scale_x_discrete(
        breaks = c("7/8", "8/4", "9/2", "10/6"),
        labels = c("Jul", "Aug", "Sep", "Oct"),
        drop = FALSE
      ) +  
      ylab(paste(pc, " ", eigs[pc], "%")) +
      theme(
        axis.title.x = element_blank(),
        plot.title = element_text(face = "bold", size = 16),
        legend.position = "none",
        plot.margin = unit(c(0.2, 0.2, 0.2, 0.2), "cm")
      ) 
}
# Cyano PC time series plots
cyano_pcs <- named_list("PC1", "PC2")

cyano_pc_plots <- lapply(cyano_pcs, 
  function(x) {
    plot_pcts(pcoa_dfs$Cyanobacteria, x, eigs = eigs$Cyanobacteria)
  }
)

# Non-cyano PC time series plots
non_cyano_pcs <- named_list("PC1", "PC2", "PC3")

non_cyano_pc_plots <- lapply(non_cyano_pcs,
  function(x) {
    plot_pcts(pcoa_dfs$NcBacteria, x, eigs = eigs$NcBacteria)
  }
)



```

## Compiled plot
```{r fig.height=7, fig.width=15}

ggdraw() +
  ## Cyano
  draw_plot(pcoa_plots$Cyanobacteria, x = 0.05, y = 0.5, width = 0.22, height = 0.43) +
  draw_plot(cyano_pc_plots$PC1, x = 0.29, y = 0.52, width = 0.22, height = 0.42) +
  draw_plot(cyano_pc_plots$PC2, x = 0.53, y = 0.52, width = 0.22, height = 0.42) +
  ## non-cyano
  draw_plot(pcoa_plots$NcBacteria, x = 0.05, y = 0, width = 0.22, height = 0.43) +
  draw_plot(non_cyano_pc_plots$PC1, x = 0.29, y = 0.02, width = 0.22, height = 0.42) +
  draw_plot(non_cyano_pc_plots$PC2, x = 0.53, y = 0.02, width = 0.22, height = 0.42) +
  draw_plot(non_cyano_pc_plots$PC3, x = 0.77, y = 0.02, width = 0.22, height = 0.42) +
  ## legend and labels
  draw_plot(pcoa_legend, x = 0.82, y = 0.57, width = 0.1, height = .35) +
  draw_plot_label(c("A", "B", "C", "D", "E", "F", "G"), 
                  c(0.05, 0.29, 0.53, 0.05, 0.29, 0.53, 0.77), 
                  c(0.97, 0.97, 0.97, 0.47, 0.47, 0.47, 0.47), 
                  size = 14) +
  draw_plot_label(c("Cyanobacteria", "Nc-Bacteria"), 
                  c(0.01, 0.01), c(.5, 0.05), size = 14, angle = 90)


```



## PERMANOVA
### Cyanobacteria

```{r}
# Remove dates for which we are missing samples for any of the sites
cyano_permanova_subset <- subset_samples(cyanos, Date != "9/29")

# Calculate bray-curtis distance
cyano_bdist <- phyloseq::distance(physeq = cyano_permanova_subset, method = "bray")

# Convert sample_data to df
sampledf <- data.frame(sample_data(cyano_permanova_subset))
```

#### time + site adonis
```{r}
# Adonis test
adonis(cyano_bdist ~ Date + Station, data = sampledf)

# Homogeneity of dispersion test
beta <- betadisper(cyano_bdist, sampledf$Date)
permutest(beta)
```

#### shore + site adonis
```{r}
# Adonis test
adonis(cyano_bdist ~ Shore + Station, data = sampledf)

# Homogeneity of dispersion test
beta <- betadisper(cyano_bdist, sampledf$Shore)
permutest(beta)

```

### Nc-Bacteria

```{r}
# Remove dates for which we are missing samples for any of the sites
non_cyano_permanova_subset <- subset_samples(non_cyanos, Date != "9/29")

# Calculate bray-curtis distance
non_cyano_bdist <- phyloseq::distance(physeq = non_cyano_permanova_subset, method = "bray")

# Convert sample_data to df
sampledf <- data.frame(sample_data(non_cyano_permanova_subset))
```

#### time + site adonis
```{r}
adonis(non_cyano_bdist ~ Date + Station, data = sampledf)
beta <- betadisper(non_cyano_bdist, sampledf$Date)
permutest(beta)
```

#### shore + site adonis
```{r}
adonis(non_cyano_bdist ~ Shore + Station, data = sampledf)
beta <- betadisper(non_cyano_bdist, sampledf$Shore)
permutest(beta)

```




# Figure 5: Actinobacteria OTU dynamics
```{r fig.height=8, fig.width=12}
# AcI is the most abundant lineage
erie_scale %>% 
  tax_glom(taxrank = "Family") %>% 
  psmelt() %>%
  group_by(Family) %>%
  summarise(mean = mean(Abundance)) %>%
  arrange(desc(mean))

# Subset to just acI
aci <- 
  erie_scale %>%
    transform_sample_counts(function(x) {x/sum(x)} ) %>%
    subset_taxa(Family == "acI") %>%
    psmelt() %>%
    order_dates()

aci_otus <- levels(aci$Species)

aci_plots <- lapply(aci_otus, 
  function(x) {
    df_otu <- filter(aci, OTU == x)
    aci_plot <- plot_otus(df = df_otu, otu = x, taxrank = "Genus")
    return(aci_plot)
  }
)


grid.arrange(
  aci_plots[[3]], aci_plots[[4]], aci_plots[[5]], aci_plots[[8]], 
  aci_plots[[1]], aci_plots[[2]], aci_plots[[6]], aci_plots[[7]], 
  station_legend,
  ncol = 4, nrow = 3
)

```


# Linear models

```{r env variables}
library(leaps)

# Function to extract the best subset multiple linear regression model 
#
# Args:
#   vars: vectors of all variables to consider in the model
#   response: response variable of the model
#   dat: dataframe with vars and response
#
# Returns: a list with the variables in the best model, bic, cp, and adjusted r2
get_bestsub_summary <- function(vars, response, dat) {
  formula = reformulate(termlabels = vars, response = response)
  lm_model <- regsubsets(formula, dat)
  bic <- summary(lm_model)$bic
  cp <- summary(lm_model)$cp
  adjr2 <- summary(lm_model)$adjr2
  best_model <- summary(lm_model)$which[which.min(bic), ]
  return(list(model = best_model, bic = bic, cp = cp, adjr2 = adjr2))
}

# Variables to include in cyano models
cyano_vars <- c("Nitrate", "SRP", "Temp", "H2O2", "SpCond", "Ammonia", "Turbidity", "Days")

# Variables to include in nc-bacteria models
non_cyano_vars <- c(cyano_vars, "pH",  "ParMC", "Chla")

# Impute SpCond values for nearshore 1 on Sep 2 and Sep 8 with value for nearshore 2
pcoa_dfs_impute <- lapply(pcoa_dfs, 
  function(x) {
    # Change 9/2 value
    x$SpCond[x$Date == "9/2" & x$Station == "nearshore1"] <- 
      x$SpCond[x$Date == "9/2" & x$Station == "nearshore2"]
    # Change 9/8 value
     x$SpCond[x$Date == "9/8" & x$Station == "nearshore1"] <- 
      x$SpCond[x$Date == "9/8" & x$Station == "nearshore2"]
    return(x)
  }
)
```

## Cyano models
```{r}

# Get the variables best subset model for the cyano community and then 
# fit the model to extract coefficients and p-values.
cyano_models <- lapply(cyano_pcs, 
  function(x) {
    best_model <- get_bestsub_summary(cyano_vars, x, dat = pcoa_dfs_impute$Cyanobacteria)
    model <- lm(
      formula = reformulate(cyano_vars[best_model$model[-1]], x), 
      data = pcoa_dfs_impute$Cyanobacteria
    )
    return(model)
  }
)
```

### PC1
```{r}
summary(cyano_models$PC1)
```

### PC2
```{r}
summary(cyano_models$PC2)
```

## Non-cyano models
```{r}
# get the variables best subset model for the non-cyano community and then 
# fit the model to extract coefficients and p-values
non_cyano_models <- lapply(non_cyano_pcs, 
  function(x) {
    best_model <- get_bestsub_summary(non_cyano_vars, x, dat = pcoa_dfs_impute$NcBacteria)
    model <- lm(
      formula = reformulate(non_cyano_vars[best_model$model[-1]], x), 
      data = pcoa_dfs_impute$NcBacteria
    )
    return(model)
  }
)

```

### PC1
```{r}
summary(non_cyano_models$PC1)
```

### PC2
```{r}
summary(non_cyano_models$PC2)
```

### PC3
```{r}
summary(non_cyano_models$PC3)
```

# Deseq tests
```{r}
# Function to run deseq2 differential abundance analysis. 
# 
# Args: 
#   physeq: a phyloseq object 
#   var: factor column in sample_data 
# Returns:
#   a df with log2fold ratios and pvalues of differentially abundant taxa
get_PC_deseq_OTUs <- function(physeq, var) {
  
  station_deseq <- phyloseq_to_deseq2(physeq, reformulate(var))
  station_deseq <- DESeq(station_deseq, test = "Wald", fitType = "parametric")
  
  my_alpha = 0.05
  res <- data.frame(results(station_deseq, cooksCutoff = FALSE, alpha = my_alpha))
  res <- data.frame(OTU = row.names(res), res)
  
  sigtab <-
    res %>%
      filter(padj < my_alpha) 

  sigtab_station <- cbind(sigtab, as(tax_table(physeq)[sigtab$OTU, ], "matrix"))
  return(sigtab_station)
}

```

```{r}
# Create factor levels for samples on PCs 
noncyano_df <-
  pcoa_dfs$NcBacteria %>%
    mutate(PC1group = ifelse(PC1 > 0, "2", "1")) %>%
    mutate(PC2group = ifelse(PC2 > 0, "2", "1")) %>%  
    mutate(PC3group = ifelse(PC3 > 0, "2", "1"))

# Deseq tests should be run on raw count data. 
# Create a new physeq object with raw counts using the OTUs from erie_prune_0001
otu_names <- tax_table(erie_prune_0001)[ ,"Species"]

non_cyano_deseq <- 
  erie %>%
    subset_taxa(Species %in% otu_names) %>%
    subset_taxa(Phylum != "Cyanobacteria")

# Add PC groups into phyloseq sample_data
sample_data(non_cyano_deseq)$PC1group <- noncyano_df$PC1group
sample_data(non_cyano_deseq)$PC2group <- noncyano_df$PC2group
sample_data(non_cyano_deseq)$PC3group <- noncyano_df$PC3group

## Make physeq objects for each station
nearshore1 <-
    non_cyano_deseq %>%
      subset_samples(Station == "nearshore1")

nearshore2 <-
    non_cyano_deseq %>%
      subset_samples(Station == "nearshore2")

offshore <-
    non_cyano_deseq %>%
      subset_samples(Station == "offshore")


stations_physeq <- named_list(nearshore1, nearshore2, offshore)

# Get the deseq OTUs for each station and each pc
stations_deseq <- lapply(stations_physeq, 
  function(x) {
    pc1_deseq <- get_PC_deseq_OTUs(x, var = "PC1group")
    pc2_deseq <- get_PC_deseq_OTUs(x, var = "PC2group")
    pc3_deseq <- get_PC_deseq_OTUs(x, var = "PC3group")
    return(list(pc1 = pc1_deseq, pc2 = pc2_deseq, pc3 = pc3_deseq))
  }
)


```

```{r}
## Find OTUs that are overabundant on the positive scores
positives <- lapply(stations_deseq, 
  function(x) {
    lapply(x, function(x) {
      filter(x, log2FoldChange > 0)
    })
  }
)

## Find OTUs that are overabundant on negative scores
negatives <- lapply(stations_deseq, 
  function(x) {
    lapply(x, function(x) {
      filter(x, log2FoldChange < 0)
    })
  }
)

tax_table <- data.frame(tax_table(erie))
```

```{r}
make_pc_table <- function(score_sign, pc) {
  pc_score <- intersect(score_sign$nearshore1[[pc]][ ,"OTU"], 
    intersect(score_sign$nearshore2[[pc]][ ,"OTU"], 
              score_sign$offshore[[pc]][ ,"OTU"]
    )
  )
}


```
## PC1 
#### Positive
```{r}
# Taxa that are overabundant on positive PC1 axis
pc1_pos <- make_pc_table(positives, "pc1")

datatable(tax_table %>% filter(Species %in% pc1_pos))
```
#### Negative
```{r}
# Taxa that are overabundant on negative PC1 axis
pc1_neg <- make_pc_table(negatives, "pc1")

datatable(tax_table %>% filter(Species %in% pc1_pos))
```

## PC2
#### Positive
```{r}
# Positive
pc2_pos <- make_pc_table(positives, "pc2")

datatable(tax_table %>% filter(Species %in% pc2_pos))
```
### Negative
```{r}
# Negative
pc2_neg <- make_pc_table(negatives, "pc2")

datatable(tax_table %>% filter(Species %in% pc2_neg))
```

## PC3
#### Positive
```{r}
pc3_pos <- make_pc_table(positives, "pc3")

datatable(tax_table %>% filter(Species %in% pc3_pos))
```
#### Negative
```{r}
# Negative
pc3_neg <- make_pc_table(negatives, "pc3")

datatable(tax_table %>% filter(Species %in% pc3_neg))
```

```{r}

# make a list of all sig OTUs
sig_otus <- named_list(pc1_pos, pc1_neg, pc2_pos, pc2_neg, pc3_pos, pc3_neg)


```

# Microcystis associates
```{r}
library(psych)

# Run correlation test with full community

# Subset to just the Microcystis OTU
mc <- 
  erie_scale %>%
    subset_taxa(Species == "Otu00005")

# Create a list of physeq objects for Microcystis at each station
mc_list <- list()
mc_list$nearshore1 <- subset_samples(mc, Station == "nearshore1") 
mc_list$nearshore2 <- subset_samples(mc, Station == "nearshore2") 
mc_list$offshore <- subset_samples(mc, Station == "offshore")

# Create a list of physeq objects for nc-bacteria at each station
erie_scale_0001_nc <- subset_taxa(erie_prune_0001, Class != "Cyanobacteria")
nc_bacteria_stations <- list()
nc_bacteria_stations$nearshore1 <- subset_samples(erie_scale_0001_nc, Station == "nearshore1")
nc_bacteria_stations$nearshore2 <- subset_samples(erie_scale_0001_nc, Station == "nearshore2")
nc_bacteria_stations$offshore <- subset_samples(erie_scale_0001_nc, Station == "offshore")

mc_corrs <- list()
Stations = c("nearshore1", "nearshore2", "offshore")

# Loop through stations, performing a spearman test between Microcystis and all non-cyanos
for (st in Stations) {
  mc_corrs[[st]] <-
    corr.test(
      x = t(otu_table(mc_list[[st]])), 
      y = t(otu_table(nc_bacteria_stations[[st]])),
      method = "pearson",
      adjust = "fdr"
    )
}

sig_corrs <- lapply(mc_corrs, 
  function(x) {
    which_sigs <- which(x$p < 0.5)
    return(colnames(x$p)[which_sigs])
  }
)

# Intersection of significant OTUs across all three sites
sig_corrs <- intersect(sig_corrs$nearshore1, 
              intersect(sig_corrs$nearshore2, sig_corrs$offshore)
            )

datatable(tax_table %>% filter(Species %in% sig_corrs))

```

# Cyanobacteria correlations 
```{r}

cyano_otu_prune <-
  erie_scale_0001 %>%
    transform_sample_counts(function(x) {x/sum(x)}) %>%
    subset_taxa(Class == "Cyanobacteria") 

# Run pairwise pearson correlation tests between all non-rare cyano OTUs
# with an fdr correction for multiple hypotheses.
cyano_corrs_pearson <- corr.test(
  t(otu_table(cyano_otu_prune)), 
  use = "pairwise", 
  method = "pearson", 
  adjust = "fdr"
)

#emphasize.strong.cells(which(cyano_corrs_pearson$p < 0.05, arr.ind = TRUE))
datatable(signif(cyano_corrs_pearson$r, digits = 2))

```

```{r}
# Save objects for the supplement
save(
  list = c("simp_plots", "obs_plots",   # alpha diversity plots
    "cyano_models", "non_cyano_models", # linear model results
    "sig_otus",                         # Deseq2 results
    "plot_otus",                        # OTU plotting function 
    "alpha_comb"),                      # alpha diversity df    
  file = "supplement.RData"
)
```

```{r}
sessionInfo()
```