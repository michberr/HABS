---
title: 'Lake Erie HABs Community Ecology Manuscript'
output:
  html_document:
    toc: true
    toc_float: true
    code_folding: show
    
---
    

```{r global_options, echo = FALSE}

knitr::opts_chunk$set(
  fig.align = 'center', 
  fig.path = 'Figs/',
  warning = FALSE, 
  message = FALSE
)

```

# Load libraries
```{r load libraries, warning=FALSE}
library(phyloseq)
library(ggplot2)
library(dplyr)
library(scales)
library(grid)
library(reshape2)
library(gridExtra)
library(vegan)
library(cowplot)
library(gtable)
library(pander)
library(tidyr)

```

# Global
```{r}
## objects and functions that will be useful throughout this analysis

# Set the ggplot theme
theme_set(theme_bw())

# Color palette for stations
station_colors = c("red", "#ffa500", "#0080ff")

# Function to order date levels correctly, including Aug 11
order_dates_aug11 <- function(df) {
  df$Date <- factor(df$Date, 
    levels = c("6/16","6/30","7/8","7/14","7/21",
      "7/29","8/4","8/11","8/18","8/25","9/2","9/8","9/15",
      "9/23","9/29","10/6","10/15","10/20","10/27"))
  return(df)
}

# Function to order date levels correctly, not including Aug 11
order_dates <- function(df) {
 df$Date <- factor(df$Date,
   levels = c("6/16","6/30","7/8","7/14","7/21",
     "7/29","8/4", "8/18","8/25","9/2","9/8","9/15",
     "9/23","9/29","10/6","10/15","10/20","10/27"))
 return(df)
}

# Function to create a named list
# Args: a vector of strings
#
# Returns: a list with the names supplied in the vector
named_list <- function(...){
    names <- as.list(substitute(list(...)))[-1L]
    result <- list(...)
    names(result) <- names
    result
}

# Source some useful functions for data normalization
source("~/git_repos/MicrobeMiseq/R/miseqR.R")
```

# Load Data
```{r phyloseq import}
load("~/git_repos/chabs/miseq_may2015/analysis/data/erie-data.RData")

# Inspect erie phyloseq object
erie
```


# Normalization
Scale counts to an even depth by dividing by total reads and multiplying by 
the minimum library size
```{r normalization}

## Scale reads in OTU table to even depth 
depth = 15000

erie_scale <- 
  erie %>%
    scale_reads(n = depth, round = "round") 


```

# Figure 1: Bloom temporal dynamics
Create figure 1, showing pigment concentrations, toxin concentration, and 
proportion of cyanobacterial reads over time and stations. 

```{r figure1, fig.height=6, fig.width=6}

# Import metadata file with nutrients, pigments and toxin
nutrient <- read.csv("~/git_repos/chabs/miseq_may2015/analysis/data/nutrient_cleaned.csv")

# Format nutrient data
nutrient_sub <- 
  nutrient %>%
    filter(!(Date %in% c("5/27", "6/10", "11/3"))) %>%
    order_dates_aug11() 

# Calculate relative abundance of Cyanobacteria at each date
cyano_abundance <- 
  erie_scale %>%
    tax_glom(taxrank = "Phylum") %>%                        # conglomerate OTUs to phylum level
    transform_sample_counts(function(x) {x/sum(x)} ) %>%    # transform to relative abundance
    subset_taxa(Phylum == "Cyanobacteria") %>%              # Subset to just Cyanobacteria
    psmelt() %>%                                            # melt phyloseq object
    rename(Cyanobacteria = Abundance) %>%
    select(Cyanobacteria, Date, Station)

# Merge cyanobacteria data with nutrient df
bloom_df <- 
  nutrient_sub %>%
    left_join(cyano_abundance, by = c("Station", "Date")) %>%
    mutate(Phycocyanin = ifelse(Phycocyanin > 80, 80, Phycocyanin)) %>%   # lower extreme values to plot better
    select(Station, Date, Phycocyanin, Chla, ParMC, Cyanobacteria) %>%
    melt(id.vars = c("Station", "Date")) %>%
    order_dates_aug11()

# Make a faceted ggplot of the four bloom variables over time and grouped by station
bloom_plots <- ggplot(bloom_df, 
  aes(x = Date, y = value, group = Station, color = Station, shape = Station)
) +
  facet_grid(variable~., scales = "free_y") +
  geom_point(size = 1.3) +
  geom_line(size = 1) + 
  ylab("") +
  scale_x_discrete(
    breaks = c("7/8", "8/4", "9/2", "10/6"),
    labels = c("Jul", "Aug", "Sep", "Oct"),
    drop = FALSE
  ) +
  scale_color_manual(values = station_colors) + 
  theme(
    strip.background = element_blank(),
    strip.text = element_text(size = 11),
    axis.title.x = element_blank()
  )

# function to extract a legend from a ggplot object
grab_legend <- function(a_ggplot) {
    tmp <- ggplot_gtable(ggplot_build(a_ggplot))
    leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
    legend <- tmp$grobs[[leg]]
    legend
}

station_legend <- grab_legend(bloom_plots) 

bloom_plots
```

## Figure 1 Statistics
```{r fig.height=3.5, fig.width=10}
par(mfrow = c(1,3))
hist(nutrient$Chla)
hist(nutrient$Phycocyanin)
hist(nutrient$ParMC)
dev.off()
```

These distributions are very non-normal. Let's try log-scaling

```{r, fig.height=3.5, fig.width=10}
par(mfrow = c(1,3))
hist(log2(nutrient$Chla), xlab = "log Chla", main = "")
hist(log2(nutrient$Phycocyanin), xlab = "log Phycocyanin", main = "")
hist(log2(nutrient$ParMC), xlab = "log ParMC", main = "")
dev.off()
```

These look better, so we will use these transformed variables for our correlation tests.
Since phycocyanin and parmc both have zeroes, we will add a constant to all values.
We selected this constant to be small and to minimally impact the distribution shape
```{r fig.height=3.5, fig.width=10}
par(mfrow = c(1,2))

logChla <- log2(nutrient$Chla)
logPhyco <- log2(nutrient$Phycocyanin + 0.1) 
logParMC <- log2(nutrient$ParMC + 0.1) 

hist(logPhyco, main = "", xlab = "log Phyco + 0.1")
hist(logParMC, main = "", xlab = "log ParMC + 0.1")
dev.off()
```


```{r}
par(mfrow = c(1,2))

plot(logChla, logPhyco, xlab = "log Chla", ylab = "log Phycocyanin") 

# Examine residuals from linear regrerssion
hist(lm(logChla~logPhyco)$residuals, xlab = "residuals", main = "log2(Chl a ~ Phycocyanin")


# Calculate linear correlation between Chla and phycocyanin for all sites
cor.test(
  x = logChla, 
  y = logPhyco, 
  alternative = "two.sided", 
  method = "pearson"
)

dev.off()
```
It looks like there is a pretty close correlation between chl a and phycocyanin
measurements. Assumptions about normality of model residuals are met
    


```{r}
par(mfrow = c(1,2))
plot(logChla, logParMC)
plot(logPhyco, logParMC)

cor.test(
  x = logChla, 
  y = logParMC, 
  alternative = "two.sided", 
  method = "pearson"
)

cor.test(
  x = logPhyco, 
  y = logParMC, 
  alternative = "two.sided", 
  method = "pearson"
)

dev.off()
```
The statistical tests show that there are significant correlations between
pigments and toxin, but the plots show that there are several dates in which 
the toxin levels are 0 but pigments are high, indicating that pigments are not
always predictive of toxicity. 


Do the nearshore and offshore sites have different bloom intensity?
```{r}
nutrient %>%
  group_by(Shore) %>%
  summarise(median(Chla))

wilcox.test(Chla ~ Shore, data = nutrient, alternative = "greater")

```


How is phycocyanin related to particulate microcystin levels in the early bloom
versus the late bloom
```{r}
################ early bloom #############################

early <- nutrient %>%
  filter(Month %in% c("June", "July", "August")) 

# Plot model
plot(x = log2(early$ParMC + 0.1), y = log2(early$Phycocyanin + 0.1))

# Fit model
fit_early <- lm(log2(ParMC + 0.1) ~ log2(Phycocyanin + 0.1), data = early)

# Check residuals to amke sure they are normal
hist(fit_early$residuals, xlab = "residuals", main = "Early bloom ParMC ~ Phycocyanin residuals")


# summary of model
summary(fit_early)



################ late bloom #############################

late <- nutrient %>%
  filter(Month %in% c("September", "October")) 

# Plot model
plot(x = log(late$ParMC + 0.1), y = log(late$Phycocyanin + 0.1))

# Fit model
fit_late <- lm(log(ParMC + 0.1) ~ log(Phycocyanin + 0.1), data = late)

# Check residuals to make sure they are normal
hist(fit_late$residuals, xlab = "residuals", main = "Late bloom ParMC ~ Phycocyanin residuals")

# summary of model
summary(fit_late)

```
Based on these two linear models, we see that the slope estimate for phycocyanin
is much lower in the late part of the bloom than the early part of the bloom. 

# Figure 2: Cyano OTUs
In this figure we will display in part A a barplot with the relative abundance of
cyanobacteria genera over time and site. In part B we will break up these groups
into OTUs and show lineplots for each non-rare OTU over time (mean rel abundance > 0.0001) and site. 


```{r}
## Select only cyano OTUs that have mean relative abundace > 0.0005
n = 15000
thresh = 0.0005

# Calculate mean relative abundance for each OTU
tax_mean <- taxa_sums(erie_scale)/nsamples(erie_scale)

# Prune low abundance taxa using thresh as mean relative abundance
erie_prune_0001 <- 
  erie_scale %>%
    prune_taxa(tax_mean > thresh*n, .)


# Create a melted data frame of selected cyanobacteria OTUs
cyano_otus <- 
  erie_prune_0001 %>%
    transform_sample_counts(function(x) {x/sum(x)}) %>%
    subset_taxa(Class == "Cyanobacteria") %>%
    psmelt() %>%
    order_dates()
```

```{r include = FALSE}
na_dates <- data.frame(OTU = rep(levels(cyano_otus$Species), 3), Station = c(rep("nearshore1", 9), rep("nearshore2", 9), rep("offshore", 9)), Date = rep("8/11", 27))

cyano_otus1 <- 
  cyano_otus %>%
    full_join(na_dates, by = c("Date" = "Date", "Station" = "Station", "OTU" = "OTU")) %>%
    order_dates()
```

```{r}
################# Plot A #######################

cyano_genus <-
  cyano_otus %>%
    group_by(Genus, Date, Station) %>%
    summarize(Abundance = sum(Abundance)) %>%
    arrange(Genus) %>%
    order_dates()


plot2a <- ggplot(cyano_genus, aes(x = Date, y = Abundance, fill = Genus)) +
  facet_grid(~Station) +
  geom_bar(stat = "identity") +
  ylab("rel. abundance") + 
  scale_x_discrete(
      breaks = c("7/8", "8/4", "9/2", "10/6"),
      labels = c("Jul", "Aug", "Sep", "Oct"),
      drop = FALSE
    ) +
  scale_fill_manual(values = c("#084594", "#41ab5d", "#ec7014" , "#88419d", "#f768a1")) + 
  theme(
    axis.title.x = element_blank(),
    axis.title.y = element_text(size = 9),
    plot.title = element_text(size = 10, face = "bold"),
    strip.background = element_blank()
  ) 

genus_legend <- grab_legend(plot2a)

plot2a <- plot2a + theme(legend.position = "none")
```



```{r}

# Function to make a ggplot lineplot of an OTU's relative abundance over time
#
# Args:
#   df: a melted data frame generated by calling psmelt() on a phyloseq object. 
#       Contains an "Abundance" column for the OTU's abundance 
#   otu: the OTU to generate a lineplot for
#   taxrank: the taxonomic rank to appear in the plot title (e.g. "Genus")
# Returns:
#   a ggplot lineplot
plot_otus <- function(df, otu, taxrank) {
  ggplot(df, 
    aes(x = Date, y = Abundance, group = Station, color = Station, shape = Station)) +
    geom_point(size = 2) +
    geom_line(size = 0.7) +
    ggtitle(paste(df[1, taxrank], otu)) +
    ylab("rel. abund") + 
    scale_color_manual(values = station_colors) +
    scale_x_discrete(
      breaks = c("7/8", "8/4", "9/2", "10/6"),
      labels = c("Jul", "Aug", "Sep", "Oct"),
      drop = FALSE
    ) +
    theme(
      axis.title.x = element_blank(),
      axis.title.y = element_text(size = 9),
      legend.position = "none",
      plot.title = element_text(size = 10, face = "bold")
    ) 
}



##################### Plot B #############################

cyano_otu_names <- as.list(levels(cyano_otus$Species))
names(cyano_otu_names) <- levels(cyano_otus$Species)


# Generate a lineplot for each cyanobacteria with mean relative abundance > 0.0001
cyano_otu_plots <- lapply(cyano_otu_names, 
  function(otu) {
    df_otu <- filter(cyano_otus, OTU == otu)
    plot <- plot_otus(df = df_otu, otu = otu, taxrank = "Genus") 
    return(plot)
  }
)

plot2b <- arrangeGrob(
  cyano_otu_plots$Otu00007, cyano_otu_plots$Otu00177, cyano_otu_plots$Otu00005,
  cyano_otu_plots$Otu00044, cyano_otu_plots$Otu00304, cyano_otu_plots$Otu00037, 
  cyano_otu_plots$Otu00147, cyano_otu_plots$Otu00193, cyano_otu_plots$Otu00049,
  ncol = 3, nrow = 3
)
```


```{r fig.width=10, fig.height=8}
##################### Compile plots #####################################

ggdraw() +
  draw_plot(plot2a, x = 0.04, y = 0.7, width = .8, height = 0.28) +
  draw_plot(genus_legend, x = 0.83, y = .76, width = .16, height = .18) + 
  draw_plot(plot2b, x = 0.02, y = 0.02, width = .8, height = 0.64) +
  draw_plot(station_legend, x = 0.80, y = .5, width = .18, height = .18) + 
  draw_plot_label(c("A", "B"), c(0.02, 0.02), c(0.97, 0.68), size = 14) 



```

What is the most abundant genus?
```{r}
cyano_genus %>%
  group_by(Genus) %>%
  summarise(median(Abundance))

```

What if we look at each site separately?
```{r}
cyano_genus %>%
  group_by(Genus, Station) %>%
  summarise(median(Abundance))
```
# Figure 3: Alpha diversity

```{r}

# My own subsetting function, similar to phyloseq::subset_taxa, except taxa can 
# be passed as arguments within functions without weird environment errors
#
# Args:
#   physeq: a phyloseq object
#   taxrank: taxonomic rank to filter on
#   taxa: a vector of taxa groups to filter on
#
# Returns: 
#   a phyloseq object subsetted to the x taxa in taxrank
my_subset_taxa <- function(physeq, taxrank, taxa) {
  physeq_tax_sub <- tax_table(physeq)[tax_table(physeq)[ , taxrank] %in% taxa, ]
  tax_table(physeq) <- physeq_tax_sub
  return(physeq)
}

```

Here we calculate the inverse simpson index for each bacterial group as well as all NcBacteria
```{r}

mytaxa <- c(
  "Actinobacteria", "Alphaproteobacteria",
  "Betaproteobacteria", "Bacteroidetes", 
  "Gammaproteobacteria", "Deltaproteobacteria", 
  "Verrucomicrobia"
)
names(mytaxa) <- mytaxa

# Taxonomic ranks of mytaxa
mytaxa_taxrank <- c(
  "Phylum", "Class", "Class", 
  "Phylum", "Class", "Class", "Phylum"
)
names(mytaxa_taxrank) <- mytaxa

# For each bacterial group, subset the phyloseq object and calculate the inverse simpson
invsimp_df <- Map(
  function(tax, rank) {
    # Subset to the taxonomic group
    erie_sub <- my_subset_taxa(physeq = erie, taxrank = rank, taxa = tax)
    # Calculate inverse simpson
    invsimp <- estimate_richness(erie_sub, measures = "InvSimpson")
  },
  mytaxa, mytaxa_taxrank
)


# Calculate inv simpson of all NcBacteria
ncbacteria <- subset_taxa(erie, Class != "Cyanobacteria")
invsimp_df$NcBacteria <- estimate_richness(ncbacteria, measures = "InvSimpson")

```

```{r}
# Merge sample metadata with these estimates
bloom_dat <- data.frame(sample_data(erie)) %>%
  select(SampleID, Chla, Station, Date, Phycocyanin, ParMC, pH, TP) %>%
  order_dates()

nutrient <- order_dates(nutrient)
ggplot(nutrient, aes(x = Date, y = TP, group = Station, color = Station)) +
  geom_point() +
  geom_line()

plot(log(bloom_dat$TP), log(bloom_dat$Chla))
plot(log(bloom_dat$TP), log(bloom_dat$Phycocyanin))
plot(log(bloom_dat$TP), bloom_dat$pH)
plot(log(bloom_dat$Chla), bloom_dat$pH)

# Create a df with a "Diversity" column that includes richness and inv. simpson,
# and log-chl a values from erie sample_data
alphadiv <- as.data.frame(invsimp_df)
names(alphadiv) <- names(invsimp_df)
alphadiv$SampleID <- rownames(alphadiv)

alphadiv_df <- alphadiv %>% 
  melt(id.vars = "SampleID", variable.name = "Group", value.name = "InvSimp") %>%
  left_join(sample_data(erie), by = c("SampleID" = "SampleID"))


```

Explore relationships between alpha-diversity and pH
```{r}
alphadiv_ph_plots <- lapply(levels(alphadiv_df$Group), function(x) {
  df <- filter(alphadiv_df, Group == x)
  ggplot(df, aes(x = pH, y = InvSimp)) +
    geom_point() +
    geom_smooth(method = "lm") +
    ggtitle(x) +
    ylab("Simpson's E")
})

do.call(grid.arrange, alphadiv_ph_plots)

# Betaproteo
betas <- filter(alphadiv_df, Group == "Betaproteobacteria")
cor.test(betas$InvSimp, betas$pH)

# Bacteroidetes
bacteroidetes <- filter(alphadiv_df, Group == "Bacteroidetes")
cor.test(bacteroidetes$InvSimp, bacteroidetes$pH)
```

Relationship between alpha-diversity and Chla
```{r}
alphadiv_chla_plots <- lapply(levels(alphadiv_df$Group), function(x) {
  df <- filter(alphadiv_df, Group == x)
  ggplot(df, aes(x = log(Chla), y = InvSimp)) +
    geom_point() +
    geom_smooth(method = "lm") +
    ggtitle(x) + 
    xlab("log2 Chla") +
    ylab("Simpson's E")
})

do.call(grid.arrange, alphadiv_chla_plots)

# Betaproteo
betas <- filter(alphadiv_df, Group == "Betaproteobacteria")
cor.test(betas$InvSimp, log(betas$Chla))

# Bacteroidetes
bacteroidetes <- filter(alphadiv_df, Group == "Bacteroidetes")
cor.test(bacteroidetes$InvSimp,log(bacteroidetes$Chla))

```

Relationship between alpha-diversity and Phycocyanin
```{r}
alphadiv_phyco_plots <- lapply(levels(alphadiv_df$Group), function(x) {
  df <- filter(alphadiv_df, Group == x)
  ggplot(df, aes(x = log(Phycocyanin + 0.1), y = InvSimp)) +
    geom_point() +
    geom_smooth(method = "lm") +
    ggtitle(x) 


do.call(grid.arrange, alphadiv_phyco_plots)

# Betaproteo
betas <- filter(alphadiv_df, Group == "Betaproteobacteria")
cor.test(betas$InvSimp, log(betas$Phycocyanin + 0.1))

# Bacteroidetes
bacteroidetes <- filter(alphadiv_df, Group == "Bacteroidetes")
cor.test(bacteroidetes$InvSimp, log(betas$Phycocyanin + 0.1))
```

Relationship between alpha-diversity and TP
```{r}
alphadiv_TP_plots <- lapply(levels(alphadiv_df$Group), function(x) {
  df <- filter(alphadiv_df, Group == x)
  ggplot(df, aes(x = log(TP), y = InvSimp)) +
    geom_point() +
    geom_smooth(method = "lm") +
    ggtitle(x)
})

do.call(grid.arrange, alphadiv_TP_plots)

# Betaproteo
betas <- filter(alphadiv_df, Group == "Betaproteobacteria")
cor.test(betas$InvSimp, log(betas$TP))

# Bacteroidetes
bacteroidetes <- filter(alphadiv_df, Group == "Bacteroidetes")
cor.test(bacteroidetes$InvSimp, log(betas$TP))

```

Relationship between alpha-diversity and Temp
```{r}
alphadiv_temp_plots <- lapply(levels(alphadiv_df$Group), function(x) {
  df <- filter(alphadiv_df, Group == x)
  ggplot(df, aes(x = Temp, y = InvSimp)) +
    geom_point() +
    geom_smooth(method = "lm") +
    ggtitle(x)
})

do.call(grid.arrange, alphadiv_temp_plots)

# Verrucomicrobia
verr <- filter(alphadiv_df, Group == "Verrucomicrobia")
cor.test(verr$InvSimp, verr$Temp)

# Gamma
gamm <- filter(alphadiv_df, Group == "Gammaproteobacteria")
cor.test(gamm$InvSimp, gamm$Temp)


```

Seasonal alpha diversity trends
```{r}
alphadiv_ncbacteria <- filter(alphadiv_df, Group == "NcBacteria") %>%
  order_dates()

seasonE <- ggplot(alphadiv_ncbacteria, aes(x = Date, y = InvSimp, group = Station, color = Station, shape = Station)) +
  geom_point() +
  geom_line() +
  scale_color_manual(values = station_colors) +
  ylab("Simpson's E") +
  xlab("") +
  scale_x_discrete(
      breaks = c("7/8", "8/4", "9/2", "10/6"),
      labels = c("Jul", "Aug", "Sep", "Oct"),
      drop = FALSE
  ) + 
  theme(legend.position = "none")

alphadiv_ncbacteria <- filter(alphadiv_df, Group == "Bacteroidetes") %>%
  order_dates()

ggplot(alphadiv_ncbacteria, aes(x = Date, y = InvSimp, group = Station, color = Station, shape = Station)) +
  geom_point() +
  geom_line() +
  scale_color_manual(values = station_colors) 

alphadiv_ncbacteria <- filter(alphadiv_df, Group == "Betaproteobacteria") %>%
  order_dates()

ggplot(alphadiv_ncbacteria, aes(x = Date, y = InvSimp, group = Station, color = Station, shape = Station)) +
  geom_point() +
  geom_line() +
  scale_color_manual(values = station_colors) 


```

```{r}
alphadiv_ncbacteria <- filter(alphadiv_df, Group == "NcBacteria") %>%
  order_dates()

plot3a <- ggplot(alphadiv_ncbacteria, aes(x = Date, y = InvSimp, group = Station, color = Station, shape = Station)) +
  geom_point() +
  geom_line() +
  scale_color_manual(values = station_colors) +
  xlab("") +
  scale_x_discrete(
      breaks = c("7/8", "8/4", "9/2", "10/6"),
      labels = c("Jul", "Aug", "Sep", "Oct"),
      drop = FALSE
  ) 

ggdraw() +
  draw_plot(seasonE, x = 0.0, y = 0.02, width = 0.3, height = 0.46) + 
  draw_plot(alphadiv_chla_plots[[8]], x = 0.34,  y = 0.04, width = .20, height = .46) +  
  draw_plot(alphadiv_chla_plots[[3]], x = 0.56,  y = 0.04, width = .20, height = .46) +
  draw_plot(alphadiv_chla_plots[[4]], x = 0.78,  y = 0.04, width = .20, height = .46) +
  draw_plot_label(c("A", "B", "C", "D", "E", "F", "G", "H"), c(0, 0.33, 0.55, 0.77), c(1, 1,1,1, .52, .52, .52, .52), size = 14)

ggsave("../plots/Figure3.pdf", width = 10, height = 6)

  
```


# Figure 4: PCoA analyses

## PCoA ordination plots

```{r}

# Subset to cyanobacteria and scale internally
cyanos <- 
  erie %>%
    subset_taxa(Class == "Cyanobacteria") %>%
    scale_reads(round = "round")


# Subset to non-cyanobacteria and scale internally
non_cyanos <- 
  erie %>%
    subset_taxa(Class != "Cyanobacteria") %>%
    scale_reads(round = "round")

# Make a list of phyloseq objects for the full community, cyanos, and non-cyanos
physeq_subsets <- list(erie_scale, cyanos, non_cyanos)
names(physeq_subsets) <- c("full", "Cyanobacteria", "NcBacteria")


# Generate pcoa scores for each subset
pcoas <- lapply(physeq_subsets, 
  function(x) {
    ordinate(
      physeq = x,
      method = "PCoA",
      distance = "bray"
    )
  }
)


# Generate a df to plot pcoa for each subset
pcoa_dfs <- lapply(pcoas,
  function(x, names) {
    p <- plot_ordination(
      physeq = erie_scale,
      axes = 1:3,
      ordination = x,
      justDF = TRUE
    )
    p$Month <- factor(p$Month, 
      levels = c("June", "July", "August", "September", "October"))
    p <- p %>% 
      rename(PC1 = Axis.1, PC2 = Axis.2, PC3 = Axis.3) %>%
      order_dates()
    return(p)
  }
)

# Flip orientation of PC2 for Cyanobacteria (does not affect interpretation)
pcoa_dfs$NcBacteria$PC2 <- -pcoa_dfs$NcBacteria$PC2

# Generate relative, lingoes-corrected eigenvalues for PC1 and PC2
eigs <- lapply(pcoas,
  function(x) {
    pcs <- c(
      PC1 = signif(x$values$Rel_corr_eig[1]*100, 3),
      PC2 = signif(x$values$Rel_corr_eig[2]*100, 3),
      PC3 = signif(x$values$Rel_corr_eig[3]*100, 3)
    )
    return(pcs)
  }
)


pcoa_plots <- Map(
  function(x, n) {
    ggplot(data = x, aes(x = PC1, y = PC2, color = Station, shape = Station)) +
      geom_point(aes(alpha = Month), size = 2.5) + 
      scale_color_manual(values = station_colors) + 
      xlab(paste("PC1 ", eigs[[n]][1], "%")) +
      ylab(paste("PC2 ", eigs[[n]][2], "%")) +
      theme(plot.margin = unit(c(0, 0.2, 0, 0.2), "cm"))
  }, 
  pcoa_dfs, names(pcoa_dfs)
)

    
# Extract legend
pcoa_legend <- grab_legend(pcoa_plots$full)

# Remove legend from plots
pcoa_plots <- lapply(pcoa_plots, 
  function(x) {x + theme(legend.position = "none")}
)


```

```{r}
# Function to create a plot of time (x-axis) vs PC scores (y-axis)
plot_pcts <- function(df, pc, eigs) {
  ggplot(df, 
    aes_string(x = "Date", y = pc, group = "Station", color = "Station", shape = "Station")) +
      geom_point(size = 2.5) +
      geom_line(size = 1.1) + 
      scale_color_manual(values = station_colors) +
      scale_x_discrete(
        breaks = c("7/8", "8/4", "9/2", "10/6"),
        labels = c("Jul", "Aug", "Sep", "Oct"),
        drop = FALSE
      ) +  
      ylab(paste(pc, " ", eigs[pc], "%")) +
      theme(
        axis.title.x = element_blank(),
        plot.title = element_text(face = "bold", size = 16),
        legend.position = "none",
        plot.margin = unit(c(0.2, 0.2, 0.2, 0.2), "cm")
      ) 
}

# Non-cyano PC time series plots
non_cyano_pcs <- named_list("PC1", "PC2", "PC3")

non_cyano_pc_plots <- lapply(non_cyano_pcs,
  function(x) {
    plot_pcts(pcoa_dfs$NcBacteria, x, eigs = eigs$NcBacteria)
  }
)

```

```{r}

# Plot for pH
ph_plot <- ggplot(pcoa_dfs$NcBacteria, aes(x = PC1, y = pH)) +
  geom_point(size = 2.5, aes(shape = Station, color = Station)) +
  scale_color_manual(values = station_colors) +
  geom_smooth(method = "lm", color = "black") +
  theme(legend.position = "none")

# Plot for Temperature
temp_plot <- ggplot(pcoa_dfs$NcBacteria, aes(x = PC2, y = Temp)) +
  geom_point(size = 2.5, aes(shape = Station, color = Station)) +
  scale_color_manual(values = station_colors) +
  geom_smooth(method = "lm", color = "black") +
  theme(legend.position = "none") +
  ylab("Temperature")

# Plot for SpCond
spcond_plot <- ggplot(pcoa_dfs$NcBacteria, aes(x = PC3, y = SpCond)) +
  geom_point(size = 2.5, aes(shape = Station, color = Station)) +
  scale_color_manual(values = station_colors) +
  geom_smooth(method = "lm", color = "black") +
  theme(legend.position = "none") +
  ylab("Specific Conductivity")

par(mfrow = c(1,3))
plot(pcoa_dfs$NcBacteria$PC1, log(pcoa_dfs$NcBacteria$TP), xlab = "PC1", ylab = "log TP")
plot(pcoa_dfs$NcBacteria$PC1, pcoa_dfs$NcBacteria$pH, xlab = "PC1", ylab = "pH")
plot(pcoa_dfs$NcBacteria$PC2, pcoa_dfs$NcBacteria$Temp, xlab = "PC2", ylab = "Temperature")


cor.test(pcoa_dfs$NcBacteria$PC1, log(pcoa_dfs$NcBacteria$TP), method = "pearson")

cor.test(pcoa_dfs$NcBacteria$PC1, pcoa_dfs$NcBacteria$pH, method = "pearson")
```

```{r}

dev.off()
```

## Compiled plot
```{r fig.height=7, fig.width=15}

ggdraw() +
  ## non-cyano
  draw_plot(non_cyano_pc_plots$PC1, x = 0.02, y = 0.5, width = 0.3, height = 0.42) +
  draw_plot(non_cyano_pc_plots$PC2, x = 0.34, y = 0.5, width = 0.3, height = 0.42) +
  draw_plot(non_cyano_pc_plots$PC3, x = 0.66, y = 0.5, width = 0.3, height = 0.42) +
  draw_plot(ph_plot, x = 0.02, y = 0.0, width = 0.3, height = 0.42) +
  draw_plot(temp_plot, x = 0.34, y = 0.0, width = 0.3, height = 0.42) +
  draw_plot(spcond_plot, x = 0.66, y = 0.0, width = 0.3, height = 0.42) 
  
 



```


```{r}
summary(lm(PC1~pH, data = pcoa_dfs$NcBacteria))

summary(lm(PC2~Temp, data = pcoa_dfs$NcBacteria))

summary(lm(PC3~SpCond, data = pcoa_dfs$NcBacteria))


```


how good is my PCoA in two dimensions?
```{r}
pcoa_dist <- as.vector(dist(pcoas$NcBacteria$vectors[,1:2]))
bray_dist <- as.vector(phyloseq::distance(non_cyanos, method = "bray"))

plot(bray_dist, pcoa_dist) +
 abline(lm(pcoa_dist~bray_dist), col = "blue")

summary(lm(pcoa_dist~bray_dist))
```

how good is my PCoA in three dimensions?
```{r}
pcoa_dist <- as.vector(dist(pcoas$NcBacteria$vectors[,1:3]))
bray_dist <- as.vector(phyloseq::distance(non_cyanos, method = "bray"))

plot(bray_dist, pcoa_dist) +
 abline(lm(pcoa_dist~bray_dist), col = "blue")

summary(lm(pcoa_dist~bray_dist))

plot(1:nrow(pcoas$NcBacteria$values), pcoas$NcBacteria$values$Rel_corr_eig)
```

What is the average bray-curtis distance
```{r}
hist(bray_dist)
mean(bray_dist)


```

## ordisurf
```{r}
ordi <- ordisurf(pcoas$NcBacteria$vectors ~ sample_data(non_cyanos)$pH)
ordi_grid <- ordi$grid
ordi_ph <- expand.grid(x = ordi_grid$x, y = ordi_grid$y) # get x's and y's
ordi_ph$z <- as.vector(ordi_grid$z) # unravel the matrix for the z scores
ordi_ph <- data.frame(na.omit(ordi_ph)) # gets rid of the na's

ggplot(pcoa_dfs$NcBacteria, aes(x = PC1, y = PC2)) +
  geom_point() +
  stat_contour(data = ordi_ph, aes(x = x, y = y, z = z, binwidth = 4))

```

http://www.fromthebottomoftheheap.net/2011/06/10/what-is-ordisurf-doing/
```{r}

n <- pcoas$NcB
ordisurf(pcoas$NcBacteria$vectors ~ sample_data(non_cyanos)$pH, main = "pH", method = "ML", select = TRUE)
ordisurf(pcoas$NcBacteria$vectors ~ sample_data(non_cyanos)$Temp, main = "Temp")
ordisurf(pcoas$NcBacteria$vectors ~ sample_data(non_cyanos)$TP, main = "TP")
ordisurf(pcoas$NcBacteria$vectors ~ sample_data(non_cyanos)$Chla, main = "Chla")
ordisurf(pcoas$NcBacteria$vectors ~ sample_data(non_cyanos)$Turbidity, main = "Turbidity", method = "ML", select = TRUE)
```

## Boostrapped models

```{r env variables}
library(leaps)

# Function to extract the best subset multiple linear regression model 
#
# Args:
#   vars: vectors of all variables to consider in the model
#   response: response variable of the model
#   dat: dataframe with vars and response
#
# Returns: a list with the variables in the best model, bic, cp, and adjusted r2
get_bestsub_summary <- function(vars, response, dat) {
  formula = reformulate(termlabels = vars, response = response)
  lm_model <- regsubsets(formula, method = "forward", dat)
  bic <- summary(lm_model)$bic
  cp <- summary(lm_model)$cp
  adjr2 <- summary(lm_model)$adjr2
  best_model <- summary(lm_model)$which[which.min(bic), ]
  return(list(model = best_model, bic = bic, cp = cp, adjr2 = adjr2))
}

# Variables to include in cyano models
cyano_vars <- c("Nitrate", "SRP", "Temp", "H2O2", "SpCond", "Ammonia", "Turbidity", "TP", "Days")

# Variables to include in nc-bacteria models
non_cyano_vars <- c(cyano_vars, "pH",  "ParMC", "Chla")

# Impute SpCond values for nearshore 1 on Sep 2 and Sep 8 with value for nearshore 2
pcoa_dfs_impute <- lapply(pcoa_dfs, 
  function(x) {
    # Change 9/2 value
    x$SpCond[x$Date == "9/2" & x$Station == "nearshore1"] <- 
      x$SpCond[x$Date == "9/2" & x$Station == "nearshore2"]
    # Change 9/8 value
     x$SpCond[x$Date == "9/8" & x$Station == "nearshore1"] <- 
      x$SpCond[x$Date == "9/8" & x$Station == "nearshore2"]
    return(x)
  }
)
```

## Non-cyano models
```{r}
# get the variables best subset model for the non-cyano community and then 
# fit the model to extract coefficients and p-values
non_cyano_models <- lapply(non_cyano_pcs, 
  function(x) {
    best_model <- get_bestsub_summary(non_cyano_vars, x, dat = pcoa_dfs_impute$NcBacteria)
    model <- lm(
      formula = reformulate(non_cyano_vars[best_model$model[-1]], x), 
      data = pcoa_dfs_impute$NcBacteria
    )
    return(model)
  }
)

```

```{r}
set.seed(1)

nboot = 100
boot_models <- list()
newdf <- list()

for (i in 1:nboot) {
  boot_sample <- sample(pcoa_dfs$NcBacteria$SampleID, replace = TRUE)
  newdf[[i]] <- pcoa_dfs_impute$NcBacteria[boot_sample, ]
  best_model <- get_bestsub_summary(non_cyano_vars, "PC1", dat = newdf[[i]])
  model <- lm(
    formula = reformulate(non_cyano_vars[best_model$model[-1]], "PC1"), 
    data = newdf[[i]]
  )
  boot_models[[i]] <- model
}

```

How many models had different vars in them?
```{r}
# What about the other vars in each of the models? 
for (var in non_cyano_vars) {
  bool_var <- sapply(boot_models, function(x) {
    var %in% names(x$coefficients)
  })
  n_var <- length(which(bool_var))/nboot
  print(paste(var, " appears in", n_var, " models."))
}
```

How frequently was pH the most significant term?

```{r}

n_ph <- sapply(boot_models, function(x) {
  "pH" %in% names(x$coefficients)
})

# Fraction of models that contain pH as a covariate
length(which(n_ph))/nboot

# Is pH the most significant?
n_sig_ph <- sapply(boot_models, function(x) {
  names(which.min(summary(x)$coef[-1, 4])) == "pH"
})

# Fraction of models that contain pH as the most significant  covariate
length(which(n_ph))/nboot
```

```{r}
# Repeat for PC2
set.seed(1)

nboot = 100
boot_models <- list()

for (i in 1:nboot) {
  boot_sample <- sample(pcoa_dfs$NcBacteria$SampleID, replace = TRUE)
  newdf <- pcoa_dfs_impute$NcBacteria[boot_sample, ]
  best_model <- get_bestsub_summary(non_cyano_vars, "PC2", dat = newdf)
  model <- lm(
    formula = reformulate(non_cyano_vars[best_model$model[-1]], "PC2"), 
    data = newdf
  )
  boot_models[[i]] <- model
}



# How many models had different vars in them?
for (var in non_cyano_vars) {
  bool_var <- sapply(boot_models, function(x) {
    var %in% names(x$coefficients)
  })
  n_var <- length(which(bool_var))/nboot
  print(paste(var, " appears in", n_var, " models."))
}
```

```{r}
# Repeat for PC3
set.seed(1)

nboot = 100
boot_models <- list()

for (i in 1:nboot) {
  boot_sample <- sample(pcoa_dfs$NcBacteria$SampleID, replace = TRUE)
  newdf <- pcoa_dfs_impute$NcBacteria[boot_sample, ]
  best_model <- get_bestsub_summary(non_cyano_vars, "PC3", dat = newdf)
  model <- lm(
    formula = reformulate(non_cyano_vars[best_model$model[-1]], "PC3"), 
    data = newdf
  )
  boot_models[[i]] <- model
}



# How many models had different vars in them?
for (var in non_cyano_vars) {
  bool_var <- sapply(boot_models, function(x) {
    var %in% names(x$coefficients)
  })
  n_var <- length(which(bool_var))/nboot
  print(paste(var, " appears in", n_var, " models."))
}



```


```{r}

n = 15000
thresh = 0.001

# Calculate mean relative abundance for each OTU
tax_mean <- taxa_sums(non_cyanos)/nsamples(non_cyanos)

# Prune low abundance taxa using thresh as mean relative abundance
nc_prune <- 
  non_cyanos %>%
    prune_taxa(tax_mean > thresh*n, .)

Species <- tax_table(nc_prune)[,"Species"]

cors <- list()

for (species in Species) {
  otu_abun <- as.numeric(otu_table(nc_prune)[species, ])
  cors[[species]] <- cor.test(otu_abun, pcoa_dfs$NcBacteria$PC1, method = "pearson")
}

p_values <- lapply(cors, function(x) {x$p.value})

w <- which(unlist(p_values) < (0.01/385))

r_values <- lapply(cors, function(x) {
  y <- x$estimate
  names(y) <- NULL
  return(y)
})

pos <- which(unlist(r_values) > 0)
neg <- which(unlist(r_values) < 0)

pc1_pos_taxa <- intersect(names(w), names(pos))

pc1_neg_taxa <- intersect(names(w), names(neg))

pc1_postax_table <- tax_table(erie)[pc1_pos_taxa,]
pc1_negtax_table <- tax_table(erie)[pc1_neg_taxa,]

p1 <- plot(pcoa_dfs$NcBacteria$PC1, as.numeric(otu_table(nc_prune)["Otu00002",]), xlab = "PC1 score", ylab = "Otu00002 LHab A1", main = paste("r:", round(cors$Otu00002$estimate, 2)))

p2 <- plot(pcoa_dfs$NcBacteria$PC1, as.numeric(otu_table(nc_prune)["Otu00004",]),xlab = "PC1 score", ylab = "Otu00004 acI-B", main = paste("r:", round(cors$Otu00004$estimate, 2)))
p3 <- plot(pcoa_dfs$NcBacteria$PC1, as.numeric(otu_table(nc_prune)["Otu00006",]),xlab = "PC1 score", ylab = "Otu00006 acI-C", main = paste("r:", round(cors$Otu00006$estimate, 2)))
p4 <- plot(pcoa_dfs$NcBacteria$PC1, as.numeric(otu_table(nc_prune)["Otu00011",]),xlab = "PC1 score", ylab = "Otu00011 acI-A", main = paste("r:", round(cors$Otu00011$estimate, 2)))

p5 <- plot(pcoa_dfs$NcBacteria$PC1, as.numeric(otu_table(nc_prune)["Otu00075",]),
xlab = "PC1 score", ylab = "Otu00075 alfII-A", main = paste("r:", round(cors$Otu00075$estimate, 2)))

p6 <- plot(pcoa_dfs$NcBacteria$PC1, as.numeric(otu_table(nc_prune)["Otu00073",]),xlab = "PC1 score", ylab = "Otu00073 Planctomyces", main = paste("r:", round(cors$Otu00073$estimate, 2)))

par(mfrow = c(2, 3))
```

```{r}

n = 15000
thresh = 0.001

# Calculate mean relative abundance for each OTU
tax_mean <- taxa_sums(non_cyanos)/nsamples(non_cyanos)

# Prune low abundance taxa using thresh as mean relative abundance
nc_prune <- 
  non_cyanos %>%
    prune_taxa(tax_mean > thresh*n, .)







```


# Microcystis associates
```{r}
library(psych)

# Run correlation test with full community

# Subset to just the Microcystis OTU
cyano <- 
  erie_scale %>%
  subset_taxa(Class == "Cyanobacteria") %>%
  tax_glom(taxrank = "Class")
    
mc <- 
  erie_scale %>%
subset_taxa(Species == "Otu00005")

corrs <-  corr.test(
    x = t(otu_table(mc)), 
    y = t(otu_table(nc_prune)),
    method = "spearman",
    use = "complete",
    adjust = "fdr"
)

which_sigs <- which(corrs$p < 0.05 & cyano_corrs$r > 0)  
sig_otus <- colnames(corrs$p)[which_sigs]

mc_corrs_dat <- data.frame(tax_table(nc_prune)) %>% filter(Species %in% sig_otus)
  
  
cyano_corrs <-  corr.test(
    x = t(otu_table(cyano)), 
    y = t(otu_table(nc_prune)),
    method = "spearman",
    use = "complete",
    adjust = "fdr"
)

which_sigs <- which(cyano_corrs$p < 0.05 & cyano_corrs$r > 0)  
sig_otus <- colnames(cyano_corrs$p)[which_sigs]




cyano_corrs_dat <- data.frame(tax_table(nc_prune)) %>% filter(Species %in% sig_otus)
  

  


# Loop through stations, performing a spearman test between Microcystis and all non-cyanos
for (st in Stations) {
  mc_corrs[[st]] <-
    corr.test(
      x = t(otu_table(mc_list[[st]])), 
      y = t(otu_table(nc_bacteria_stations[[st]])),
      method = "spearman"
    )
}

sig_corrs <- lapply(mc_corrs, 
  function(x) {
    which_sigs <- which(x$p < 0.2)
    return(colnames(x$p)[which_sigs])
  }
)

# Intersection of significant OTUs across all three sites
sig_corrs <- intersect(sig_corrs$nearshore1, 
              intersect(sig_corrs$nearshore2, sig_corrs$offshore)
            )


View( data.frame(tax_table(nc_prune)) %>% filter(Species %in% sig_corrs))

```

# Figure 5: Actinobacteria OTU dynamics
```{r fig.height=8, fig.width=12}
# AcI is the most abundant lineage
nc_prune %>% 
  tax_glom(taxrank = "Family") %>% 
  psmelt() %>%
  group_by(Family) %>%
  summarise(mean = mean(Abundance)) %>%
  arrange(desc(mean))

# Subset to just acI
aci <- 
  erie_scale %>%
    transform_sample_counts(function(x) {x/sum(x)} ) %>%
    subset_taxa(Family == "acI") %>%
    psmelt() %>%
    order_dates()

aci_otus <- levels(aci$Species)

aci_plots <- lapply(aci_otus, 
  function(x) {
    df_otu <- filter(aci, OTU == x)
    aci_plot <- plot_otus(df = df_otu, otu = x, taxrank = "Genus")
    return(aci_plot)
  }
)


grid.arrange(
  aci_plots[[3]], aci_plots[[4]], aci_plots[[5]], aci_plots[[8]], 
  aci_plots[[1]], aci_plots[[2]], aci_plots[[6]], aci_plots[[7]], 
  station_legend,
  ncol = 4, nrow = 3
)

```


# AcIV
```{r fig.height=8, fig.width=12}

# Subset to just acI
aciIV <- 
  erie_scale %>%
    transform_sample_counts(function(x) {x/sum(x)} ) %>%
    subset_taxa(Family == "Planctomycetaceae") %>%
    psmelt() %>%
    order_dates()

aci_otus <- levels(aciIV$Species)

aci_plots <- lapply(aci_otus, 
  function(x) {
    df_otu <- filter(aciIV, OTU == x)
    aci_plot <- plot_otus(df = df_otu, otu = x, taxrank = "Genus")
    return(aci_plot)
  }
)


grid.arrange(
  aci_plots[[3]], aci_plots[[4]], aci_plots[[5]], aci_plots[[8]], 
  aci_plots[[1]], aci_plots[[2]], aci_plots[[6]], aci_plots[[7]], 
  station_legend,
  ncol = 4, nrow = 3
)

```

# BacI
```{r fig.height=8, fig.width=12}

# Subset to just acI
aciIV <- 
  erie_scale %>%
    transform_sample_counts(function(x) {x/sum(x)} ) %>%
    subset_taxa(Family == "bacI") %>%
    psmelt() %>%
    order_dates()

aci_otus <- levels(aciIV$Species)

aci_plots <- lapply(aci_otus, 
  function(x) {
    df_otu <- filter(aciIV, OTU == x)
    aci_plot <- plot_otus(df = df_otu, otu = x, taxrank = "Genus")
    return(aci_plot)
  }
)


grid.arrange(
  aci_plots[[3]], aci_plots[[4]], aci_plots[[5]], aci_plots[[8]], 
  aci_plots[[1]], aci_plots[[2]], aci_plots[[6]], aci_plots[[7]], 
  station_legend,
  ncol = 4, nrow = 3
)

```

# BetI
```{r fig.height=8, fig.width=12}

# Subset to just acI
aciIV <- 
  erie_scale %>%
    transform_sample_counts(function(x) {x/sum(x)} ) %>%
    subset_taxa(Family == "betI") %>%
    psmelt() %>%
    order_dates()

aci_otus <- levels(aciIV$Species)

aci_plots <- lapply(aci_otus, 
  function(x) {
    df_otu <- filter(aciIV, OTU == x)
    aci_plot <- plot_otus(df = df_otu, otu = x, taxrank = "Genus")
    return(aci_plot)
  }
)


grid.arrange(
  aci_plots[[3]], aci_plots[[4]], aci_plots[[5]], aci_plots[[8]], 
  aci_plots[[1]], aci_plots[[2]], aci_plots[[6]], aci_plots[[7]], 
  station_legend,
  ncol = 4, nrow = 3
)

```

# LunaI
```{r}
# Subset to just acI
aciIV <- 
  erie_scale %>%
    transform_sample_counts(function(x) {x/sum(x)} ) %>%
    subset_taxa(Family == "Luna1") %>%
    psmelt() %>%
    order_dates()

aci_otus <- levels(aciIV$Species)

aci_plots <- lapply(aci_otus, 
  function(x) {
    df_otu <- filter(aciIV, OTU == x)
    aci_plot <- plot_otus(df = df_otu, otu = x, taxrank = "Genus")
    return(aci_plot)
  }
)


grid.arrange(
  aci_plots[[3]], aci_plots[[4]], aci_plots[[5]],
  aci_plots[[1]], aci_plots[[2]], aci_plots[[6]], 
  station_legend,
  ncol = 4, nrow = 3
)





```


```{r}
subset <- subset_samples(ncbacteria, Date != "10/27" & !is.na(SpCond))
# Generate pcoa scores for each subset
ncbact_cca <- ordinate(
  physeq = subset,
  method = "CCA",
  distance = "bray",
  formula = ~ pH + SpCond + Temp
)

# Generate a df to plot pcoa for each subset
cca <- plot_ordination(
  physeq = subset,
  axes = 1:3,
  ordination = ncbact_pcoa,
  color = "Month",
  shape = "Station"
)

# Now add the environmental variables as arrows
arrowmat <- vegan::scores(ncbact_cca, display = "bp")

# Add labels, make a data.frame
arrowdf <- data.frame(labels = rownames(arrowmat), arrowmat)

# Define the arrow aesthetic mapping
arrow_map <- aes(xend = .5 * CCA1, 
    yend = .5* CCA2, 
    x = 0, 
    y = 0, 
    shape = NULL, 
    color = NULL, 
    label = labels)

label_map <- aes(x = .5 * CCA1, 
    y = .5 * CCA2, 
    shape = NULL, 
    color = NULL, 
    label = labels)

arrowhead = arrow(length = unit(0.02, "npc"))

# Make a new graphic
cca + 
  geom_segment(
    mapping = arrow_map, 
    size = .5, 
    data = arrowdf, 
    color = "gray", 
    arrow = arrowhead
  ) + 
  geom_text(
    mapping = label_map, 
    size = 4,  
    data = arrowdf, 
    show.legend = FALSE
  )




###################################
ncbact_nmds <- ordinate(
  physeq = ncbacteria,
  method = "NMDS",
  distance = bdist,
  justDF = TRUE
)


sample_data(ncbacteria)$Month <- factor(sample_data(ncbacteria)$Month, levels = c("June", "July", "August", "September", "October"))


pcoa_df <- plot_ordination(
  physeq = ncbacteria,
  ordination = ncbact_nmds,
  color = "Month",
  shape = "Station"
)


```

library(leaps)

# Function to extract the best subset multiple linear regression model 
#
# Args:
#   vars: vectors of all variables to consider in the model
#   response: response variable of the model
#   dat: dataframe with vars and response
#
# Returns: a list with the variables in the best model, bic, cp, and adjusted r2
get_bestsub_summary <- function(vars, response, dat) {
  formula = reformulate(termlabels = vars, response = response)
  lm_model <- regsubsets(formula, dat, nvmax = 1)
  bic <- summary(lm_model)$bic
  cp <- summary(lm_model)$cp
  adjr2 <- summary(lm_model)$adjr2
  best_model <- summary(lm_model)$which[which.max(adjr2), ]
  return(list(model = best_model, bic = bic, cp = cp, adjr2 = adjr2))
}


```{r}


Now we will run a stability analysis, performing 100 bootstrap resamplings
of the data and refitting the model each time
```{r}
set.seed(1)

nboot = 100


# Loop through each principle coordinate, and then do 100 boostrap resamplings
boot_pc_models <- lapply(ncbact_pcs, function(x) { 
  boot_models <- list()
  newdf <- list()
  for (i in 1:nboot) {
    boot_sample <- sample(pcoa_df$SampleID, replace = TRUE)
    newdf[[i]] <- pcoa_df[boot_sample, ]
    best_model <- get_bestsub_summary(non_cyano_vars, x, dat = newdf[[i]])
    model <- lm(
      formula = reformulate(non_cyano_vars[best_model$model[-1]], x), 
      data = newdf[[i]]
    )
    boot_models[[i]] <- model
  }
  return(boot_models)
  
})
```

    

How many models had different vars in them?
```{r}
for (pc in ncbact_pcs) {
  print(pc)
  for (var in non_cyano_vars) {
    bool_var <- sapply(boot_pc_models[[pc]], function(x) {
      var %in% names(x$coefficients)
    })
    n_var <- length(which(bool_var))/nboot
    print(paste(var, "appears in", n_var, "models."))
  }

}

```

How frequently was pH the most significant term for PC1?

```{r}

n_ph <- sapply(boot_pc_models$PC1, function(x) {
  "pH" %in% names(x$coefficients)
})

# Fraction of models that contain pH as a covariate
length(which(n_ph))/nboot

# Is pH the most significant?
n_sig_ph <- sapply(boot_pc_models, function(x) {
  names(which.min(summary(x)$coef[-1, 4])) == "pH"
})

# Fraction of models that contain pH as the most significant  covariate
length(which(n_ph))/nboot
```


```{r}



ncbact_hell <- erie %>%
  scale_reads(n = 1000,) %>%
  subset_samples(Date != "10/27")

otu_hell <- decostand(x = t(otu_table(ncbact_hell)), method = "hellinger")

# Environmental data
env_df <- pcoa_df[1:50, non_cyano_vars]
env_df <- data.frame(scale(env_df))

mod1 <- rda(otu_hell~., env_df)

mod0 <- rda(otu_hell ~ 1, env_df)
mod <- step(mod0, scope = formula(mod1), test = "perm")


cyano_vars <- c("Nitrate", "SRP", "Temp", "H2O2", "SpCond", "Ammonia", "Turbidity", "TP", "Days", "Chla", "Phycocyanin", "ParMC")

rda_fit <- rda(otu_hell ~ Days + pH + SpCond + Phycocyanin + TP + ParMC + Temp, data =env_df)

par(mfrow = c(1,3))
plot(rda_fit, c(1,2))
plot(rda_fit, c(2,3))
plot(rda_fit, c(1,3))

scores <- data.frame(SampleID = rownames(scores(rda_fit)$sites), scores(rda_fit)$sites)
new_df <- pcoa_df %>%
  left_join(scores, by = c("SampleID" = "SampleID"))
```

