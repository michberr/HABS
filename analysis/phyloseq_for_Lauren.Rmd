---
title: "Phyloseq Demo"
output:
  html_document:
    toc: true
    theme: united
---


# Libraries
```{r load libraries,warning=FALSE,message=FALSE}
#Load libraries
library(phyloseq)
packageVersion("phyloseq")
library(Biostrings)
library(ggplot2)
library(vegan)
library(plyr)
library(scales)
library(grid)
library(reshape2)
library(gridExtra)
library(RColorBrewer)


# Set working directory
setwd("~/habs/genomics/data/")

```

# Data import
```{r mothur import}

# Import mothur files and sample metadata
sharedfile = "mothur/allhabs.shared"
taxfile = "mothur/allhabs.taxonomy"
mapfile = "best_metadata.csv"
 
mothurdata = import_mothur(mothur_shared_file = sharedfile,
                             mothur_constaxonomy_file = taxfile)

# Add the OTU number as a column in the taxonomy file
tax_table(mothurdata) <- cbind(tax_table(mothurdata),
                               row.names(tax_table(mothurdata)))

# Rename the taxonomy columns
colnames(tax_table(mothurdata)) <- c("Kingdom","Phylum","Class",
                                       "Order","Family","Genus","Species")
  
# Import sample metadata
map <- read.csv(mapfile)
map <- sample_data(map)
rownames(map) <- map$SampleID
  
# Merge mothurdata object with sample metadata
moth_merge = merge_phyloseq(mothurdata,map)

# Filter out non-samples (i.e. water,mock) and samples from intensive cruises.
# Also prune out taxa which were only present in removed samples
moth_good <- subset_samples(moth_merge,Type=="sample")
moth_good <- prune_taxa(taxa_sums(moth_good)>0,moth_good)

# Filter out non-bacteria, chloroplasts and mitochondria
moth_good <- subset_taxa(moth_good, Kingdom == "Bacteria")
moth_good <- subset_taxa(moth_good, Class != "Chloroplast")
moth_good <- subset_taxa(moth_good, Family!="mitochondria")



```

```{r functions,echo=FALSE}
### all the functions####

##### FUNCTIONS ########

# Scale reads using mcmurdie holmes method to a given library size of n
scale_reads <- function(physeq,n) {
  physeq.scale <-
    transform_sample_counts(physeq, function(x) {
      (n * x / sum(x))
    })
  otu_table(physeq.scale) = floor(otu_table(physeq.scale))
  physeq.scale = prune_taxa(taxa_sums(physeq.scale) > 0,physeq.scale)
  return(physeq.scale)
}

# Order dates correctly in a data frame
order_dates <- function(df) {
  df$Date <-
    factor(
      df$Date, levels = c(
        "5/27","6/10","6/16","6/30","7/8","7/14","7/21",
        "7/29","8/4","8/11","8/18","8/25","9/2","9/8","9/15",
        "9/23","9/29","10/6","10/15","10/20","10/27","11/3"
      )
    )
  return(df)
}

# Function to run adonis test on a distance object and a categorical variable from a metadata data frame
doadonis <- function(physeq, category) {
  physeq.scale <- scale_reads(physeq,min(sample_sums(physeq)))
  bdist <- phyloseq::distance(physeq.scale,"bray")
  col = as(sample_data(physeq),"data.frame")[,category]
  adonis.bdist = adonis(bdist ~ col)
  print(adonis.bdist)
  paste("The Homogeneity of dispersion \n")
  
  
  # Homogeneity of dispersion test
  betatax = betadisper(bdist,col)
  p = permutest(betatax)
  print("The homogeneity of dispersion:")
  print(p$tab)
}


# Function to make a pcoa plot with bray-cutis distance where color variable is discrete
make_pcoa <- function(physeq) {
  physeq.scale <- scale_reads(physeq,min(sample_sums(physeq)))
  sample_data(physeq.scale) <-
    order_dates(sample_data(physeq.scale))
  set.seed(1)
  physeq.bray.nmds = ordinate(physeq.scale,method = "PCoA","bray")
}


# This function takes a phyloseq object, agglomerates OTU's to the desired taxonomic rank, prunes out OTUs below a certain relative proportion in a sample (ie 1% ) and melts the phyloseq object into long format.
transform_and_melt <- function(physeq, taxrank, prune) {
  # Agglomerate all otu's by phylum level
  physeq_taxrank <- tax_glom(physeq,taxrank = taxrank)
  
  # Create a new phyloseq object which removes taxa from each sample below the prune parameter
  physeq_taxrank.prune <- transform_sample_counts(physeq_taxrank,
                                                  function(x) {
                                                    x / sum(x)
                                                  })
  otu_table(physeq_taxrank.prune)[otu_table(physeq_taxrank.prune) < prune] <-
    0
  physeq_taxrank.prune <-
    prune_taxa(taxa_sums(physeq_taxrank.prune) > 0,
               physeq_taxrank.prune)
  
  # Set all samples from 8/11 to 0 because of bad sampling on that date
  w <- which(sample_data(physeq_taxrank.prune)$Date == "8/11")
  otu_table(physeq_taxrank.prune)[,w] <- 0
  
  # Melt into long format and sort by samplenum and phylum
  physeq_taxrank.long <- psmelt(physeq_taxrank.prune)
  physeq_taxrank.long <-
    arrange(physeq_taxrank.long,Samplenum,Phylum)
  
  
  # Reorder factor levels for dates
  physeq_taxrank.long <- order_dates(physeq_taxrank.long)
  
  # Reorder factor levers for stations
  physeq_taxrank.long$Station <- factor(physeq_taxrank.long$Station,
                                        levels = c("WE2","WE12","WE4"))
  
  # Reorder factor levels for Fraction. Change Fraction factor names
  physeq_taxrank.long$Fraction <-
    factor(physeq_taxrank.long$Fraction,
           levels = c("CNA","100LTR","53LTR","3NA","22NA"))
  
  levels(physeq_taxrank.long$Fraction) <-
    c("Full", "100um", "53um","3um","0.22um")
  
  # Return long data frame
  return(physeq_taxrank.long)
}

# This function takes  a data frame in long format (such as the output from transform_and_melt) and produces a stacked barplot of community composition.
make_tax_barplot <-
  function(df,x,y,tax,facet,title,colors,xlab,ylab,relative,outline,guide) {
    ggplot(df, aes_string(x = x, y = y, fill = tax)) +
      facet_grid(reformulate(facet)) +
      geom_bar(stat = "identity", show_guide = guide) +
      scale_fill_manual(values = colors) +
      scale_x_discrete(
        breaks = c("6/10", "7/8",
                   "8/4", "9/2", "10/6", "11/3"),
        labels = c("Jun", "Jul",
                   "Aug", "Sep", "Oct", "Nov"),
        drop = FALSE
      ) +
      theme(
        axis.title.x = element_text(size = 16,face = "bold"),
        axis.text.x = element_text(
          angle = 50, colour = "black", vjust = 1, hjust = 1, size = 13
        ),
        axis.text.y = element_text(colour = "black", size = 10),
        axis.title.y = element_text(face = "bold", size = 16),
        plot.title = element_text(size = 18),
        legend.title = element_text(size = 14),
        legend.text = element_text(size = 13),
        legend.position = "right",
        strip.text.x = element_text(size = 16, face = "bold"),
        strip.text.y = element_text(size = 16, face = "bold"),
        strip.background = element_rect(
          color = "white",size = 2,fill = NA
        ),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.border = element_rect(
          colour = "black",fill = NA,size = 1.5
        ),
        panel.margin = unit(1, "lines"),
        panel.background = element_rect(fill = "#a8a8a8")
      ) +
      guides(fill = guide_legend(
        reverse = TRUE,keywidth = 1,keyheight = 1
      )) +
      xlab(xlab) +
      ylab(ylab) +
      ggtitle(title) +
      if (relative) {
        geom_bar(
          stat = "identity",position = "fill", colour = outline,show_guide = FALSE
        )
      } else {
        geom_bar(stat = "identity",colour = outline,show_guide = FALSE)
      }
    
  }

```

# Sample summary
A lot of the 100um samples have very low read counts because a majority of the reads were chloroplasts. Before removing non-bacteria, all samples had at least 10,000 reads, afterwards many of the 100L samples had as few as 500 reads. This is important to keep in mind for beta diversity analyses, because to include all the samples we need to really throw out a lot of data to normalize the sequencing depth.

```{r,echo=FALSE}
# Histogram of sample read counts
ggplot(data.frame(sum=sample_sums(moth_good)), aes(sum)) + 
  geom_histogram(colour="white", fill="indianred") +
  ggtitle("Sample read counts") + 
  xlab("total sequences")

# mean, max and min of sample read counts
mins <- min(sample_sums(moth_good))
means <- mean(sample_sums(moth_good))
maxs <- max(sample_sums(moth_good))

```
The minimum sample read count is $mins
The mean sample read count is $means
The max sample read count is $maxs

# Full Community Analysis

## Stacked barplot

Time series of phylum community composition across filter fractions and sampling stations
```{r composition barplot, fig.height=10,fig.width=14}

# Set phylum colors
phylum.colors <- c(
  "#CBD588", "#5F7FC7", "orange","#DA5724","#89C5DA","#508578" , "#CD9BCD",
  "#74D944", "#D7C1B1", "#AD6F3B", "#673770","#D14285","#689030",
  "#6DDE88", "#652926", "#7FDCC0", "#C84248", "#8569D5", "#5E738F",
  "#D1A33D", "#8A7C64", "#599861"
)


# Transform to long format and prune out phyla below 2% in each sample
moth.long <- transform_and_melt(physeq = moth_good,taxrank = "Phylum",prune = .05)

# Plot 
make_tax_barplot(
  df = moth.long, x = "Date", y = "Abundance",
  tax = "Phylum",
  facet = "Fraction~Station",
  title = "",
  colors = phylum.colors,
  xlab = "",
  ylab = "Relative Abundance\n",
  outline = "black",
  relative = TRUE,
  guide = TRUE
)


```

## Ordinations

### Unconstrained
```{r}
CNA <- subset_samples(moth_good,Fraction=="CNA")

CNA.scale <- scale_reads(CNA,min(sample_sums(CNA)))

sample_data(CNA.scale)$Station <- factor(sample_data(CNA.scale)$Station,
                                         levels=c("WE2","WE4","WE12"))

sample_data(CNA.scale)$Month <- factor(sample_data(CNA.scale)$Month,
                                       levels=c("May","June","July","August",
                                                "September","October","November"))

cna.scale.bray= ordinate(CNA.scale, method="PCoA", "bray")

theme_set(theme_bw())
plot_ordination(physeq = CNA.scale,
                              ordination = cna.scale.bray,
                              color = "Month",
                              shape = "Station",
                              axes = c(1,2)) + 
              geom_point(aes(colour = Month),alpha=.7, size = 4) +
              geom_point(colour="grey90", size = 1.5) + 
              scale_color_manual(values=c("#a65628","red","#ffae19",
                                          "#4daf4a","#1919ff",
                                          "darkorchid3","magenta")) +
              theme(plot.margin = unit(c(2,2,2,2), "lines"))


```


### Constrained 

```{r}

cna <- subset_samples(moth_good,Fraction == "CNA")
cna.scale <- scale_reads(cna, n = 10000)
cna.scale <- prune_samples(sample_sums(cna.scale)>0, cna.scale)


cna.scale.sub <-
  subset_samples(
    cna.scale,!is.na(LogPhyco) & 
      !is.na(SRP) &
      !is.na(DOC) &
      !is.na(pH) & 
      !is.na(ParMC) & 
      !is.na(H2O2)
  )

bdist <- phyloseq::distance(physeq = cna.scale.sub,method = "bray")

sample_data(cna.scale.sub)$Month <-
  factor(
    sample_data(cna.scale.sub)$Month,
    levels = c(
      "May","June","July","August",
      "September","October","November"
    )
  )
                                    


# CAP
cap.ord<-ordinate(physeq = cna.scale.sub,method = "CAP",
                  distance = bdist,
                  formula = ~ ParMC + Nitrate + SRP + LogPhyco + Ammonia + DOC + pH + H2O2)


cap.plot <- plot_ordination(cna.scale.sub,cap.ord,color="Month",axes = c(1,2)) + 
            aes(shape = Station) +
            geom_point(aes(colour = Month),alpha=.2, size = 4) +
            geom_point(colour="grey90", size = 1.5) + 
            scale_color_manual(values=c("#a65628","red","#ffae19",
                                        "#4daf4a","#1919ff",
                                        "darkorchid3","magenta"))


# Now add the environmental variables as arrows
arrowmat <- vegan::scores(cap.ord, display = "bp")

# Add labels, make a data.frame
arrowdf <- data.frame(labels = rownames(arrowmat), arrowmat)

# Define the arrow aesthetic mapping
arrow_map <- aes(xend = CAP1, yend = CAP2, x = 0, y = 0, 
                shape = NULL, color = NULL, 
                label = labels)

label_map <- aes(x = 1.3 * CAP1, y = 1.3 * CAP2, shape = NULL, 
                 color = NULL, label = labels)

arrowhead = arrow(length = unit(0.02, "npc"))

# Make a new graphic
p1 = cap.plot + 
     geom_segment(arrow_map, size = .5, 
                             data = arrowdf, color = "gray", 
                             arrow = arrowhead) + 
    geom_text(label_map, size = 4,face="bold", 
                data = arrowdf,show_guide=FALSE)

p1
```

Do a permutational ANOVA on constrained axes used in ordination
```{r}
anova(cap.ord)
```


# Differential abundance of OTUs

Now we will test which OTUs are differentially abundant between our fraction with large algal colonies (>100um) and smaller algal colonies (53-100um)

Note: normally you should filter out low-abundance OTUs before running these tests. These low abundance OTUs will create the most noise in your model and are *maybe/probably* less important to your community than more abundant OTUs. I did not do that here because these two fractions i'm comparing have overall very low diversity 

```{r}
library(DESeq2)
# Subset to just the samples from the 100um and 53um fractions
just53and100 <- subset_samples(moth_good, Fraction %in% c("100LTR","53LTR"))

# Convert phyloseq object to deseq object
# When creating your model, deseq always compares 
fdeseq <- phyloseq_to_deseq2(just53and100,~Fraction)

#This step will estimate size factors, dispersion, and fit model. It will take a few minutes to run
fdeseq=DESeq(fdeseq)

#Store the results
res=results(fdeseq)

#Reorder the results according to the adjusted P-value (Adjusted because of multiple tests)
res=res[order(res$padj,na.last=NA),]

#Choose a threshold for p-value
alpha=.01

#Store only OTU's that were below that p-value
sigtab <- res[(res$padj<alpha),]

# Add in taxonomic names for OTUs into sigtab matrix
sigtab <- cbind(as(sigtab, "data.frame"), as(tax_table(moth_good)[rownames(sigtab),], "matrix"))

# Phylum 
x = tapply(sigtab$log2FoldChange, sigtab$Phylum, function(x) max(x))
x = sort(x, TRUE)
sigtab$Phylum = factor(as.character(sigtab$Phylum), levels=names(x))

# Genus
x = tapply(sigtab$log2FoldChange, sigtab$Genus, function(x) max(x))
x = sort(x, TRUE)
sigtab$Genus = factor(as.character(sigtab$Genus), levels=names(x))

# Plot
theme_set(theme_bw())
ggplot(sigtab, aes(x=Genus, y=log2FoldChange, color=Phylum)) + geom_point(size=6) + 
  theme(axis.text.x = element_text(angle = -90, hjust = 0, vjust=0.5)) + 
  ggtitle("Differentially abundant OTUs \n between 100um and 53um water fractions")


```


Note: DESeq2 assumes the first level in your factor is the control. In this case, 100um comes before 53um, so OTUs that have a positive log2foldchange are more abundant in the 53um fraction than the 100um fraction and vice versa

# Functions

```{r}
### all the functions####

##### FUNCTIONS ########

# Scale reads using mcmurdie holmes method to a given library size of n
scale_reads <- function(physeq,n){
  physeq.scale <- transform_sample_counts(physeq, function(x) {(n*x/sum(x))})
  otu_table(physeq.scale) = floor(otu_table(physeq.scale))
  physeq.scale = prune_taxa(taxa_sums(physeq.scale)>0,physeq.scale)
  return(physeq.scale)
}

# Order dates correctly in a data frame
order_dates <- function(df){
  df$Date <- factor(df$Date, levels = c("5/27","6/10","6/16","6/30","7/8","7/14","7/21",
                                        "7/29","8/4","8/11","8/18","8/25","9/2","9/8","9/15",
                                        "9/23","9/29","10/6","10/15","10/20","10/27","11/3"))
  return(df)
}

# Function to run adonis test on a distance object and a categorical variable from a metadata data frame
doadonis <- function(physeq, category) {
  physeq.scale <- scale_reads(physeq,min(sample_sums(physeq)))
  bdist<-phyloseq::distance(physeq.scale,"bray")
  col = as(sample_data(physeq),"data.frame")[,category]
  
 # Run adonis test and print results
  adonis.bdist=adonis(bdist~col)
  print(adonis.bdist) 
 
 # Homogeneity of dispersion test
  betatax=betadisper(bdist,col)
  p=permutest(betatax)
  print("The homogeneity of dispersion:") 
  print(p$tab)
}  


# Function to make a pcoa plot with bray-cutis distance where color variable is discrete
make_pcoa <- function(physeq){
  physeq.scale <- scale_reads(physeq,min(sample_sums(physeq)))
  sample_data(physeq.scale) <- order_dates(sample_data(physeq.scale))
  set.seed(1)
  physeq.bray.nmds = ordinate(physeq.scale,method="PCoA","bray")
}  
  

# This function takes a phyloseq object, agglomerates OTU's to the desired taxonomic rank, prunes out OTUs below a certain relative proportion in a sample (ie 1% ) and melts the phyloseq object into long format.
transform_and_melt <- function(physeq, taxrank, prune) {
  
  # Agglomerate all otu's by taxonomic level
  physeq_glom <- tax_glom(physeq, taxrank = taxrank)
  
  # Create a new phyloseq object which removes taxa from each sample below the prune parameter
  physeq_prune <- transform_sample_counts(physeq_glom,
                                                  function(x) {
                                                    x / sum(x)
                                                  })
  otu_table(physeq_prune)[otu_table(physeq_prune) < prune] <- 0
  physeq_prune <-
    prune_taxa(taxa_sums(physeq_prune) > 0,
               physeq_prune)
  
  # Set all samples from 8/11 to 0 because of bad sampling on that date
  w <- which(sample_data(physeq_prune)$Date == "8/11")
  otu_table(physeq_prune)[,w] <- 0
  
  # Melt into long format and sort by samplenum and phylum
  physeq_long <- psmelt(physeq_prune)
  physeq_long <-
    arrange(physeq_long, Samplenum, Phylum)
  
  # Reorder factor levels for dates
  physeq_long <- order_dates(physeq_long)
  
  # Reorder factor levers for stations
  physeq_long$Station <- factor(physeq_long$Station,
                                        levels = c("WE2", "WE12", "WE4"))
  
  # Reorder factor levels for Fraction. Change Fraction factor names
  physeq_long$Fraction <-
    factor(physeq_long$Fraction,
           levels = c("CNA", "100LTR", "53LTR", "3NA", "22NA"))
  
  levels(physeq_long$Fraction) <-
    c("Full", "100um", "53um", "3um", "0.22um")
  
  # Return long data frame
  return(physeq_long)
}
  
# This function takes  a data frame in long format (such as the output from transform_and_melt) and produces a stacked barplot of community composition.   
make_tax_barplot<-function(df,x,y,tax,facet,title,colors,xlab,ylab,relative,outline,guide){
  ggplot(df,aes_string(x=x,y=y,fill=tax)) +
        facet_grid(reformulate(facet))+
        geom_bar(stat="identity",show_guide=guide)+
    scale_fill_manual(values = colors) + 
    scale_x_discrete(breaks=c("6/10","7/8",
                              "8/4","9/2","10/6","11/3"),
                      labels=c("Jun", "Jul",
                                "Aug", "Sep",  "Oct","Nov"),
                     drop=FALSE
                     )+
    theme(axis.title.x = element_text(size=16,face="bold"),
          axis.text.x = element_text(angle=50, colour = "black", vjust=1, hjust = 1, size=13),
          axis.text.y = element_text(colour = "black", size=10),
          axis.title.y = element_text(face="bold", size=16),
          plot.title = element_text(size = 18),
          legend.title = element_text(size=14),
          legend.text = element_text(size = 13),
          legend.position="right",
          strip.text.x = element_text(size=16, face="bold"),
          strip.text.y = element_text(size=16, face="bold"),
          strip.background = element_rect(color="white",size=2,fill=NA),
          panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
          panel.border = element_rect(colour = "black",fill=NA,size=1.5),
          panel.margin = unit(1, "lines"),
          panel.background = element_rect(fill="#a8a8a8")
      ) +
    guides(fill = guide_legend(reverse= TRUE,keywidth=1,keyheight=1))+
    xlab(xlab)+
    ylab(ylab)+
    ggtitle(title)+
    if (relative){
          geom_bar(stat="identity",position="fill", colour=outline,show_guide=FALSE) 
        } else {
          geom_bar(stat="identity",colour=outline,show_guide=FALSE) 
    }  
        
}




```